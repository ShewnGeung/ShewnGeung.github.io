<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kotlin基础学习从入门到入土 | ShewnGeung</title><meta name="author" content="ShewnGeung"><meta name="copyright" content="ShewnGeung"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="Kotlin基础数据类型在kotlin中，变量使用var关键字声明，常量使用val关键字声明。 变量声明可以通过变量名:数据类型的形式显式声明，也可以通过自动推导的方式声明。 123456&#x2F;&#x2F;通过【变量名:数据类型】的形式声明变量var name: String &#x3D; &quot;Soria&quot;val age: Int &#x3D; 18&#x2F;&#x2F;可以不显式声明数据类型，可以自动推导var height &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin基础学习从入门到入土">
<meta property="og:url" content="https://shewngeung.github.io/kotlin/Kotlin-Tutorial/index.html">
<meta property="og:site_name" content="ShewnGeung">
<meta property="og:description" content="Kotlin基础数据类型在kotlin中，变量使用var关键字声明，常量使用val关键字声明。 变量声明可以通过变量名:数据类型的形式显式声明，也可以通过自动推导的方式声明。 123456&#x2F;&#x2F;通过【变量名:数据类型】的形式声明变量var name: String &#x3D; &quot;Soria&quot;val age: Int &#x3D; 18&#x2F;&#x2F;可以不显式声明数据类型，可以自动推导var height &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://shewngeung.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-04-19T05:55:49.000Z">
<meta property="article:modified_time" content="2024-02-18T11:33:12.000Z">
<meta property="article:author" content="ShewnGeung">
<meta property="article:tag" content="Kotlin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shewngeung.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://shewngeung.github.io/kotlin/Kotlin-Tutorial/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kotlin基础学习从入门到入土',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-18 19:33:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/cat.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><div id="myscoll"></div><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ShewnGeung"><span class="site-name">ShewnGeung</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/pictures/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Kotlin基础学习从入门到入土</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-19T05:55:49.000Z" title="发表于 2023-04-19 13:55:49">2023-04-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-18T11:33:12.000Z" title="更新于 2024-02-18 19:33:12">2024-02-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/kotlin/">kotlin</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Kotlin基础"><a href="#Kotlin基础" class="headerlink" title="Kotlin基础"></a>Kotlin基础</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>在kotlin中，<strong>变量使用<code>var</code>关键字声明，常量使用<code>val</code>关键字声明</strong>。</p>
<p>变量声明可以通过<code>变量名:数据类型</code>的形式显式声明，也可以通过自动推导的方式声明。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过【变量名:数据类型】的形式声明变量</span></span><br><span class="line"><span class="keyword">var</span> name: String = <span class="string">&quot;Soria&quot;</span></span><br><span class="line"><span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">18</span></span><br><span class="line"><span class="comment">//可以不显式声明数据类型，可以自动推导</span></span><br><span class="line"><span class="keyword">var</span> height = <span class="number">1.75</span></span><br><span class="line"><span class="keyword">var</span> weight = <span class="number">55</span></span><br></pre></td></tr></table></figure>

<p>Kotlin支持八种基本数据类型：<code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Char</code>、<code>Boolean</code>。</p>
<ol>
<li><p>数字类型</p>
<p>数字类型包括<code>Byte</code>、<code>Short</code>、<code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> byteNum: <span class="built_in">Byte</span> = <span class="number">127</span></span><br><span class="line"><span class="keyword">val</span> shortNum: <span class="built_in">Short</span> = <span class="number">32767</span></span><br><span class="line"><span class="keyword">val</span> intNum: <span class="built_in">Int</span> = <span class="number">2147483647</span></span><br><span class="line"><span class="keyword">val</span> longNum: <span class="built_in">Long</span> = <span class="number">9223372036854775807L</span></span><br><span class="line"><span class="keyword">val</span> floatNum: <span class="built_in">Float</span> = <span class="number">3.14F</span></span><br><span class="line"><span class="keyword">val</span> doubleNum: <span class="built_in">Double</span> = <span class="number">3.141592653589793</span></span><br><span class="line"><span class="comment">//无符号类型</span></span><br><span class="line"><span class="keyword">val</span> uByteNum: UByte = 255u</span><br><span class="line"><span class="keyword">val</span> uShortNum: UShort = 65535u</span><br><span class="line"><span class="keyword">val</span> uIntNum: UInt = 4294967295u</span><br><span class="line"><span class="keyword">val</span> uLongNum: ULong = 18446744073709551615u</span><br></pre></td></tr></table></figure>

<p>各个类型的取值范围如下所示：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">位数</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Byte</code></td>
<td align="center"><code>8</code></td>
<td align="center"><code>-128 ~ 127</code></td>
</tr>
<tr>
<td align="center"><code>Short</code></td>
<td align="center"><code>16</code></td>
<td align="center"><code>-32768 ~ 32767</code></td>
</tr>
<tr>
<td align="center"><code>Int</code></td>
<td align="center"><code>32</code></td>
<td align="center"><code>-2^31^ ~ 2^31^-1</code></td>
</tr>
<tr>
<td align="center"><code>Long</code></td>
<td align="center"><code>64</code></td>
<td align="center"><code>-2^63^ ~ 2^63^-1</code></td>
</tr>
<tr>
<td align="center"><code>Float</code></td>
<td align="center"><code>32</code></td>
<td align="center"><code>1.4^-45^ ~ 3.4028235^38^</code></td>
</tr>
<tr>
<td align="center"><code>Double</code></td>
<td align="center"><code>64</code></td>
<td align="center"><code>4.9^-324^ ~ 1.7976931348623157^308^</code></td>
</tr>
</tbody></table>
<p>整型默认的数据类型为<code>Int，</code>浮点型为<code>Double</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下数据类型均为Int类型</span></span><br><span class="line"><span class="keyword">val</span> num1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> num2 = <span class="number">123</span></span><br><span class="line"><span class="keyword">val</span> num3 = <span class="number">123456</span></span><br><span class="line"><span class="comment">//以下数据类型均为Double类型</span></span><br><span class="line"><span class="keyword">val</span> num4 = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">val</span> num5 = <span class="number">123.456</span></span><br><span class="line"><span class="keyword">val</span> num6 = <span class="number">123456.789</span></span><br></pre></td></tr></table></figure>

<p>在Kotlin中，<strong>可以用”_”分隔数字</strong>，便于阅读。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> num = <span class="number">1_000_000</span></span><br></pre></td></tr></table></figure>

<p>Kotlin支持二进制和十六进制表示，<strong>不支持八进制表示</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> binNum = <span class="number">0b11110000</span></span><br><span class="line"><span class="keyword">val</span> hexNum = <span class="number">0x1f1e33</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>boolean</code>类型</p>
<p><code>boolean</code>类型只有<code>true</code>和<code>false</code>两个值。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> booleanTrue = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> booleanFalse = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><code>boolean</code>类型也可以通过关系运算得到。常用的关系运算符如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> boolean1 = <span class="number">12</span> &gt; <span class="number">10</span>   <span class="comment">//true</span></span><br><span class="line"><span class="keyword">val</span> boolean2 = <span class="number">12</span> == <span class="number">10</span>   <span class="comment">//false</span></span><br><span class="line"><span class="keyword">val</span> boolean3 = <span class="number">12</span> != <span class="number">10</span>   <span class="comment">//false</span></span><br><span class="line"><span class="keyword">val</span> boolean4 = <span class="number">12</span> &lt;= <span class="number">10</span>   <span class="comment">//false</span></span><br><span class="line"><span class="keyword">val</span> boolean5 = <span class="number">7</span> <span class="keyword">in</span> <span class="number">1.</span>.&lt;<span class="number">10</span>   <span class="comment">//true [1,10)</span></span><br><span class="line"><span class="keyword">val</span> boolean6 = <span class="number">10</span> !<span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span>   <span class="comment">//false [1,10]</span></span><br><span class="line"><span class="keyword">val</span> boolean7 = <span class="number">12</span> <span class="keyword">is</span> <span class="built_in">Int</span>   <span class="comment">//true</span></span><br><span class="line"><span class="keyword">val</span> boolean8 = <span class="number">7</span> &lt; <span class="number">10</span> &amp;&amp; <span class="number">12</span> &gt; <span class="number">10</span>   <span class="comment">//true</span></span><br><span class="line"><span class="keyword">val</span> boolean9 = <span class="number">7</span> &lt; <span class="number">10</span> || <span class="number">12</span> &gt; <span class="number">10</span>   <span class="comment">//true</span></span><br><span class="line"><span class="keyword">val</span> boolean10 =!<span class="literal">true</span>   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符和字符串类型</p>
<p><code>Char</code>类型是一个单一的<strong>unicode字符</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> char1 = <span class="string">&#x27;a&#x27;</span>   <span class="comment">//a</span></span><br><span class="line"><span class="keyword">val</span> char2 = <span class="string">&#x27;\u0061&#x27;</span>    <span class="comment">//a</span></span><br><span class="line"><span class="keyword">val</span> char3 = <span class="string">&#x27;\uFF21&#x27;</span>    <span class="comment">//A</span></span><br><span class="line"><span class="keyword">val</span> char4 = <span class="string">&#x27;A&#x27;</span>.code   <span class="comment">//65</span></span><br></pre></td></tr></table></figure>

<p>String类型通常用” “表示，也可以使用”””(模板字符串)多行表示。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str1 = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="keyword">val</span> str2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Hello</span></span><br><span class="line"><span class="string">    World</span></span><br><span class="line"><span class="string">    Kotlin</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>.trimIndent()	<span class="comment">//trimIndent()用于清除缩进</span></span><br><span class="line"><span class="keyword">val</span> str3 = <span class="string">&quot;Kotlin&quot;</span></span><br><span class="line"><span class="keyword">val</span> str4 = <span class="string">&quot;<span class="variable">$str3</span> hello, world!<span class="subst">$&#123;str3&#125;</span>&quot;</span>   <span class="comment">//Kotlin hello, world!Kotlin</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符如下所示。</p>
<table>
<thead>
<tr>
<th align="center">转义字符</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>\t</code></td>
<td align="center">制表符</td>
</tr>
<tr>
<td align="center"><code>\b</code></td>
<td align="center">退格</td>
</tr>
<tr>
<td align="center"><code>\n</code></td>
<td align="center">换行(LF)</td>
</tr>
<tr>
<td align="center"><code>\r</code></td>
<td align="center">回车(CR)</td>
</tr>
<tr>
<td align="center"><code>\&#39;</code></td>
<td align="center">单引号</td>
</tr>
<tr>
<td align="center">\“</td>
<td align="center">双引号</td>
</tr>
<tr>
<td align="center"><code>\\</code></td>
<td align="center">反斜杠</td>
</tr>
<tr>
<td align="center"><code>\$</code></td>
<td align="center">美元符</td>
</tr>
</tbody></table>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>Kotlin提供了相关的位运算操作，仅适用于<code>Int</code>和<code>Long</code>类型的变量。</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th align="center">操作说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>shl(num)</code></td>
<td align="center">左移</td>
</tr>
<tr>
<td align="center"><code>shr(num)</code></td>
<td align="center">右移</td>
</tr>
<tr>
<td align="center"><code>ushr(num)</code></td>
<td align="center">无符号右移</td>
</tr>
<tr>
<td align="center"><code>and(bits)</code></td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center"><code>or(bits)</code></td>
<td align="center">按位或</td>
</tr>
<tr>
<td align="center"><code>xor(bits)</code></td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center"><code>inv()</code></td>
<td align="center">取反</td>
</tr>
</tbody></table>
<blockquote>
<p>  [!IMPORTANT]</p>
<p>  <em>不存在无符号左移。</em></p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左移shl(num)</span></span><br><span class="line"><span class="keyword">val</span> num1 = <span class="number">13</span>    <span class="comment">// 13 00001101</span></span><br><span class="line"><span class="keyword">val</span> num2 = num1 shl <span class="number">1</span>    <span class="comment">// 26 00011010</span></span><br><span class="line"><span class="comment">//右移shr(num)</span></span><br><span class="line"><span class="keyword">val</span> num3 = <span class="number">144</span>    <span class="comment">//144 10010000</span></span><br><span class="line"><span class="keyword">val</span> num4 = num3 shr <span class="number">1</span>    <span class="comment">//72 01001000</span></span><br><span class="line"><span class="comment">//无符号右移ushr(num)</span></span><br><span class="line"><span class="keyword">val</span> num5 = -<span class="number">1</span>    <span class="comment">//-1 11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="keyword">val</span> num6 = num5 ushr <span class="number">1</span>    <span class="comment">//2147483647 01111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//按位与、或、异或(and、or、xor)</span></span><br><span class="line"><span class="keyword">val</span> num7 = <span class="number">12</span>   <span class="comment">//12 00001100</span></span><br><span class="line"><span class="keyword">val</span> num8 = num7 and <span class="number">0b00000110</span>   <span class="comment">//4 00000100</span></span><br><span class="line"><span class="keyword">val</span> num9 = num7 or <span class="number">0b00000110</span>   <span class="comment">//14 00001110</span></span><br><span class="line"><span class="keyword">val</span> num10 = num7 xor <span class="number">0b00000110</span>   <span class="comment">//10 00001000</span></span><br><span class="line"><span class="comment">//取反(inv)</span></span><br><span class="line"><span class="keyword">val</span> num11 = <span class="number">127</span>   <span class="comment">//127 01111111</span></span><br><span class="line"><span class="keyword">val</span> num12 = num11.inv()   <span class="comment">//-128 10000000</span></span><br></pre></td></tr></table></figure>

<h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="if-else和when"><a href="#if-else和when" class="headerlink" title="if-else和when"></a>if-else和when</h4><p>在Kotlin中，<code>if</code>语句与java类似，但是还提供了一种单行表达式的写法，类似于三元运算符。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">10</span></span><br><span class="line"><span class="comment">//常规写法</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>)&#123;</span><br><span class="line">    println(<span class="string">&quot;x &gt; 10&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;x &lt;= 10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单行表达式写法</span></span><br><span class="line"><span class="comment">//类似于 x == 10 ? true : false</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">10</span>) println(<span class="string">&quot;x &gt; 10&quot;</span>) <span class="keyword">else</span> println(<span class="string">&quot;x &lt;= 10&quot;</span>)</span><br><span class="line"><span class="comment">//if的结果也可用于变量</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">if</span> (x &gt; <span class="number">10</span>) <span class="string">&quot;x &gt; 10&quot;</span> <span class="keyword">else</span> <span class="string">&quot;x &lt;= 10&quot;</span></span><br><span class="line"><span class="comment">//多行代码块的结果默认以最后一行作为返回结果</span></span><br><span class="line"><span class="keyword">val</span> result2 = <span class="keyword">if</span> (x &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    <span class="string">&quot;x &gt; 10&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="string">&quot;x &lt;= 10&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>when</code>类似于java中的<code>switch</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; println(<span class="string">&quot;x = 1&quot;</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; println(<span class="string">&quot;x = 2&quot;</span>)</span><br><span class="line">    <span class="number">3</span> -&gt; println(<span class="string">&quot;x = 3&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; println(<span class="string">&quot;x is not 1, 2, or 3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和if-else同理，也可以用一个变量接收when返回的值</span></span><br><span class="line"><span class="keyword">val</span> value = <span class="keyword">when</span> &#123;</span><br><span class="line">    x &gt; <span class="number">0</span> -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若某些值属于同一情况，则可以通过&quot;,&quot;合并</span></span><br><span class="line"><span class="keyword">val</span> value1 = <span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1.</span><span class="number">.3</span> -&gt; <span class="string">&quot;x is 1, 2, or 3&quot;</span></span><br><span class="line">    <span class="keyword">in</span> <span class="number">4.</span><span class="number">.5</span> -&gt; <span class="string">&quot;x is 4 or 5&quot;</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">&quot;x is other value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若所有的情况都可以被说明，则可以省略else</span></span><br><span class="line"><span class="keyword">val</span> isTrue = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> value2 = <span class="keyword">when</span> (isTrue) &#123;</span><br><span class="line">    <span class="literal">true</span> -&gt; <span class="number">1</span></span><br><span class="line">    <span class="literal">false</span> -&gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="for和while"><a href="#for和while" class="headerlink" title="for和while"></a>for和while</h4><p><code>for</code>采用 <code>for(x in array)</code> 的形式，除此之外<code>break</code>和<code>continue</code>的用法同java。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">    println(i)  <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100</span> step <span class="number">2</span>) &#123;</span><br><span class="line">    println(i)  <span class="comment">// 1 3 5 7 9... 99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以通过【标签@ + @标签】的形式，使多循环中的break或continue结束外层循环</span></span><br><span class="line"><span class="symbol">xxx@</span> <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">40</span> downTo <span class="number">1</span> step <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0.</span>.i step <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">break</span><span class="symbol">@xxx</span> <span class="keyword">else</span> println(j)    <span class="comment">// 0 10 20 30</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Text after break&quot;</span>)    <span class="comment">//该语句并不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>while</code>和<code>do-while</code>语句同java。</p>
<h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><p>在Kotlin中，函数使用<code>fun</code>关键字声明。</p>
<p>Kotlin中的函数定义更加简洁和灵活。例如，我们可以在一个函数中定义另一个局部函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行foo(2)会返回4</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">multi</span><span class="params">(y: <span class="type">Int</span>)</span></span> = y * <span class="number">2</span></span><br><span class="line">    println(multi(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>函数的参数可以带有默认值，如果调用时不传入参数，则使用默认值作为传入的参数。我们也可以手动指定传入的参数对应哪一个形参。</em></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sayHello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接调用sub()则返回5</span></span><br><span class="line"><span class="comment">//调用sub(b = 10)则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sub</span><span class="params">(a: <span class="type">Int</span> = <span class="number">10</span>, b: <span class="type">Int</span> = <span class="number">5</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个函数较为简单，类似于上面的<code>sub()</code>，则可以采用如下方式简写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiply</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a * b</span><br><span class="line"><span class="comment">//求斐波那契数列第n项，最基础的实现方式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fibonacci</span><span class="params">(n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span> (n <span class="keyword">in</span> <span class="number">1.</span><span class="number">.2</span>) <span class="number">1</span> <span class="keyword">else</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>然而使用上述方法求解斐波那契时，存在了大量的重复运算。通过使用<code>tailrec</code>关键字对函数进行修饰，我们可以进行尾递归优化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 1 2 3 5 8 13 21 34 55 89 144</span></span><br><span class="line"><span class="comment">//执行fibonacci(1, 1, 9)返回89</span></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">fibonacci</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, n: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        a</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fibonacci(b, a + b, n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  [!NOTE]</p>
<p>  如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作。</p>
<p>  <strong><code>tailrec</code>就是让递归变成了迭代，因此<code>tailrec</code>关键字只能优化尾递归算法，其它递归算法无法优化。</strong></p>
</blockquote>
<p>Kotlin支持在缺省函数名的情况下，直接定义一个函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(num: <span class="type">Int</span>, condition: (<span class="type">Int</span>) -&gt; <span class="type">Boolean</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (condition(num)) &#123;</span><br><span class="line">        num * <span class="number">2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        num / <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//此处使用匿名函数</span></span><br><span class="line">    calculate(<span class="number">5</span>, <span class="function"><span class="title">fun</span><span class="params">(num:<span class="type">Int</span>)</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num <span class="keyword">in</span> <span class="number">1.</span><span class="number">.10</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的重载同java。</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="函数类型变量"><a href="#函数类型变量" class="headerlink" title="函数类型变量"></a>函数类型变量</h3><p>在Kotlin中，函数类型的格式非常简单。举个例子：<code>(Int) -&gt; Unit</code>。</p>
<p>函数类型的声明需要遵循以下几点：</p>
<ol>
<li>通过<code>-&gt;</code>组织参数类型和返回值类型。左边是参数类型，右边是返回值类型。</li>
<li><strong>必须用<code>()</code>包裹参数类型。</strong></li>
<li>返回值类型即使是<code>Unit</code>也必须显式声明。</li>
</ol>
<p>如果一个函数类型没有参数，则可以通过<code>() -&gt; Unit</code>表示。如果有多个参数，则通过”,”进行分隔：<code>(Int, String) -&gt; Unit</code>。</p>
<p>如果一个参数是可选的，则可以用”?”来表示。如果该函数类型的变量也是可选的，则可以将整个函数类型变为可选。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg在某种情况下不需要传入，则可以如下表示</span></span><br><span class="line"><span class="keyword">val</span> a: (code: <span class="built_in">Int</span>, msg: String?) -&gt; <span class="built_in">Unit</span></span><br><span class="line"><span class="comment">//整个函数类型也可以变为可选</span></span><br><span class="line"><span class="keyword">val</span> b:((code: <span class="built_in">Int</span>, msg: String)-&gt;<span class="built_in">Unit</span>)?</span><br></pre></td></tr></table></figure>

<p>函数类型的变量还可以返回另一个函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这表示传入一个Int类型的参数，返回一个类型为(Int) -&gt; Unit的函数</span></span><br><span class="line"><span class="keyword">val</span> c: (<span class="built_in">Int</span>) -&gt; (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x -&gt; &#123; y -&gt; x + y &#125; &#125;</span><br><span class="line"><span class="comment">//下面则表示传入一个函数类型的参数，返回Unit</span></span><br><span class="line"><span class="keyword">val</span> d: ((<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; f -&gt; f(<span class="number">2</span>) &#125;</span><br><span class="line"><span class="comment">//当然还可以接着套娃</span></span><br><span class="line"><span class="keyword">val</span> e: (<span class="built_in">Int</span>) -&gt; ((<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; x -&gt; &#123; y -&gt; x + y(x) &#125; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>在Kotlin中，可以通过Lambda表达式简化匿名函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行println(sum(1, 2))会返回3</span></span><br><span class="line"><span class="keyword">val</span> sum: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; a, b -&gt; a + b &#125;</span><br><span class="line"><span class="comment">//如果不需要使用某个变量，可以用_代替</span></span><br><span class="line"><span class="keyword">val</span> sum2: (<span class="built_in">Int</span>, <span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; _, b -&gt; b &#125;</span><br></pre></td></tr></table></figure>

<p>我们可以直接把Lambda作为参数传入，作为实参使用。下述情况被称为尾随Lambda表达式，只有在最后一个参数是函数类型的情况下才可以使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(func: (<span class="type">Int</span>) -&gt; <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(func(<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">test2</span><span class="params">(num:<span class="type">Int</span>,func: (<span class="type">Int</span>) -&gt; <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(func(num))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下均会打印&quot;收到的参数：10&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test(&#123; <span class="string">&quot;收到的参数：<span class="variable">$it</span>&quot;</span> &#125;)</span><br><span class="line">    <span class="comment">//如果函数的最后一个形参是函数类型，可以直接写在括号后面</span></span><br><span class="line">    test()&#123;<span class="string">&quot;收到的参数: <span class="variable">$it</span>&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//此时()内不存在参数，因此可以省略()</span></span><br><span class="line">    test&#123;<span class="string">&quot;收到的参数: <span class="variable">$it</span>&quot;</span>&#125;</span><br><span class="line">    <span class="comment">//如果在上述前提下，()还有其它参数，则只能如下表示</span></span><br><span class="line">    test2(<span class="number">10</span>)&#123; <span class="string">&quot;收到的参数: <span class="variable">$it</span>&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数调用的是尾随Lambda表达式，默认的标签名为函数名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">(func: (<span class="type">Int</span>) -&gt; <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    println(func(<span class="number">12</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    printName&#123;</span><br><span class="line">        <span class="keyword">if</span>(it &gt; <span class="number">5</span>) <span class="keyword">return</span><span class="symbol">@printName</span> <span class="string">&quot;提前返回的结果&quot;</span></span><br><span class="line">        println(<span class="string">&quot;正常情况&quot;</span>)</span><br><span class="line">        <span class="string">&quot;收到的参数: <span class="variable">$it</span>&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Lambda中不能使用<code>return</code>返回结果。</strong></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>在Kotlin中使用Lambda表达式会带来一些额外的开销。我们可以通过<code>inline</code>关键字修饰函数，使其成为内联函数。被<code>inline</code>修饰的函数，在执行时会将函数体嵌入每一个被调用的地方，以减少额外生成的匿名类数，以及函数执行时的时间开销。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    test &#123; println(it) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(func: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;这是一个内联函数&quot;</span>)</span><br><span class="line">    func(<span class="string">&quot;inline function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码相当于：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    println(<span class="string">&quot;这是一个内联函数&quot;</span>)    <span class="comment">// test()第一行</span></span><br><span class="line">    <span class="keyword">val</span> it = <span class="string">&quot;inline function&quot;</span>    <span class="comment">// 函数内传入的参数</span></span><br><span class="line">    println(it)    <span class="comment">// 调用传入的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内联函数会导致编译后的代码变多，但是获得了性能上的提升。该操作对高阶函数有显著的效果，对于普通的函数即使使用内联函数也不会获得多少提升。</p>
<p><strong>内联函数中的函数形参无法作为值给到变量，只能调用。</strong></p>
<p>由于内联导致代码直接被搬运，所以Lambda中的return语句可以不带标签。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test&#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    println(<span class="string">&quot;调用上述方法之后...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(func: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    func(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;调用内联函数之后...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码运行后不会输出任何内容。这种情况被称为<em>非局部返回</em>。因为Lambda中的<code>return</code>作用于整个main()，可以通过<code>@标签</code>更改其作用域来防止非局部返回。</p>
<p>为了避免带有<code>return</code>的Lambda参数产生破坏，可以用<code>crossinline</code>关键字修饰该参数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码执行后将会打印&quot;调用内联函数之后...&quot;和&quot;调用上述方法之后...&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test&#123; <span class="keyword">return</span><span class="symbol">@test</span> &#125;</span><br><span class="line">    println(<span class="string">&quot;调用上述方法之后...&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">test</span><span class="params">(func: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    func(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;调用内联函数之后...&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个函数一旦被定义为内联函数，边不能获取闭包类中的私有成员，除非将它们声明为<code>internal</code>。</p>
<p>通过<code>noinline</code>关键字修饰参数可以使其不具有内联的效果。</p>
<h2 id="中缀函数"><a href="#中缀函数" class="headerlink" title="中缀函数"></a>中缀函数</h2><p>通过<code>infix</code>关键字修饰的函数被称为中缀函数，在调用时可以通过<code>A 中缀方法 B</code>的形式调用，省略了”.”和”()”。中缀函数在使用时必须满足以下条件：</p>
<ul>
<li>必须是某个类型的扩展函数或者成员方法；</li>
<li>只能有一个参数，参数不能有默认值；</li>
<li>该参数不能是可变参数。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Name</span>(<span class="keyword">val</span> name: String)&#123;</span><br><span class="line">    <span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(other: <span class="type">String</span>)</span></span> = Name(<span class="keyword">this</span>.name + other)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name1 = Name(<span class="string">&quot;John&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> name2 = name1 add <span class="string">&quot;Doe&quot;</span></span><br><span class="line">    println(name2.name)    <span class="comment">// JohnDoe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  [!NOTE]</p>
<p>  Kotlin通过<code>vararg</code>关键字定义函数中的可变参数，类似于java中的<code>...</code>。在java中可变参数必须是最后一个参数，而在Kotlin中没有这个限制。</p>
<p>  我们还可以使用<code>*</code>来将外部变量作为可变参数的变量。</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printLetter</span><span class="params">(<span class="keyword">vararg</span> letters: <span class="type">String</span>)</span></span> = println(letters.joinToString())</span><br><span class="line">printLetter(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>) <span class="comment">// &quot;a, b, c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> letters = arrayOf(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>)</span><br><span class="line">printLetter(*letters) <span class="comment">// &quot;a, b, c, d, e&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="Kotlin核心"><a href="#Kotlin核心" class="headerlink" title="Kotlin核心"></a>Kotlin核心</h1><h2 id="类和初始化"><a href="#类和初始化" class="headerlink" title="类和初始化"></a>类和初始化</h2><p>Kotlin中的类和java类似。</p>
<p>通常，类中一般具有一些属性。在Kotlin中，可以通过<code>constructor</code>关键字添加属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果主构造函数没有任何注释或可见性修饰符，则可以省略<code>constructor</code>，如果类中没有内容，则可以省略<code>&#123;&#125;</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(name: String, age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>上述仅仅定义了构造函数的参数，还不是类的属性。可以在上述参数前添加<code>var</code>或者<code>val</code>来表示这个属性是可变还是不可变的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<p>一个类可以有一个主构造函数和多个次构造函数。次构造函数中可以自定义函数体。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String): <span class="keyword">this</span>(name, <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">constructor</span>(age: <span class="built_in">Int</span>): <span class="keyword">this</span>(<span class="string">&quot;Unknown&quot;</span>, age)&#123;</span><br><span class="line">        println(<span class="string">&quot;Age is <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student1 = Student(<span class="string">&quot;Soria&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;student1.name&#125;</span>: <span class="subst">$&#123;student1.age&#125;</span>&quot;</span>)    <span class="comment">// Soria：18</span></span><br><span class="line">    <span class="keyword">val</span> student2 = Student(<span class="string">&quot;John&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;student2.name&#125;</span>: <span class="subst">$&#123;student2.age&#125;</span>&quot;</span>)    <span class="comment">// John：24</span></span><br><span class="line">    <span class="keyword">val</span> student3 = Student(<span class="number">16</span>)    <span class="comment">// Age is 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Kotlin中，可以通过<code>init</code>关键字进行初始化，类似于java中的<code>static</code>。但在Kotlin中，可以存在多个<code>init</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;学生对象被创建了<span class="subst">$&#123;name&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;学生对象被创建了<span class="subst">$&#123;age&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;学生对象被创建了<span class="subst">$&#123;name&#125;</span>:<span class="subst">$&#123;age&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String):<span class="keyword">this</span>(name, <span class="number">24</span>) &#123;</span><br><span class="line">        println(<span class="string">&quot;次构造函数执行...&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 执行结果如下</span></span><br><span class="line">    <span class="comment">// 学生对象被创建了ShewnGeung</span></span><br><span class="line">    <span class="comment">// 学生对象被创建了24</span></span><br><span class="line">    <span class="comment">// 学生对象被创建了ShewnGeung:24</span></span><br><span class="line">    <span class="comment">// 次构造函数执行...</span></span><br><span class="line">    <span class="keyword">val</span> student4 = Student(<span class="string">&quot;ShewnGeung&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的扩展"><a href="#类的扩展" class="headerlink" title="类的扩展"></a>类的扩展</h3><p>Kotlin提供了扩展类或接口的操作，来为某个类添加一些额外的函数或属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为Kotlin内置的String类添加一个test函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">text</span><span class="params">()</span></span> = println(<span class="keyword">this</span>)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;Soria&quot;</span></span><br><span class="line">    <span class="comment">// 可以直接使用，就好像String类中真的有这个函数一样</span></span><br><span class="line">    name.text()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的扩展是静态的，并不会修改它们原本的类，也不会将新成员插入到类中，仅仅是将我们定义的功能变得可调用。如果要扩展属性，只能明确定义一个<code>getter</code>和<code>setter</code>来创建扩展属性。</p>
<p>如果命名发生冲突时，需要特别处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Hello from A&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="keyword">private</span> <span class="keyword">val</span> a: A)&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;Hello from B&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> A.<span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        hello()    <span class="comment">// 优先匹配被扩展类中的函数</span></span><br><span class="line">        <span class="keyword">this</span>.hello()    <span class="comment">// 扩展函数中的this依然指的是被扩展的类对象</span></span><br><span class="line">        <span class="keyword">this</span><span class="symbol">@B</span>.hello()    <span class="comment">// 手动指定了B类中hello()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类本身就具有同名同参数的函数，那么扩展函数将失效。但如果通过扩展类实现函数的重载，完全没有问题。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Test.<span class="title">hello</span><span class="params">()</span></span> = println(<span class="string">&quot;hi&quot;</span>)    <span class="comment">// 扩展失效</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Test.<span class="title">hello</span><span class="params">(name: <span class="type">String</span>)</span></span> = println(<span class="string">&quot;hello <span class="variable">$name</span>&quot;</span>)    <span class="comment">// 可以重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test().hello()    <span class="comment">// hello</span></span><br><span class="line">    Test().hello(<span class="string">&quot;Soria&quot;</span>)    <span class="comment">// hello Soria</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果将一个扩展函数作为参数给到一个函数类型变量，需要在具体操作之前增加类型名称。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> len:String.() -&gt; <span class="built_in">Int</span> = &#123; <span class="keyword">this</span>.length &#125;</span><br><span class="line">println(<span class="string">&quot;soria&quot;</span>.len())</span><br></pre></td></tr></table></figure>

<h3 id="运算符重载函数"><a href="#运算符重载函数" class="headerlink" title="运算符重载函数"></a>运算符重载函数</h3><p>Kotlin支持为程序中已知的运算符集提供自定义实现。要实现运算符重载，应为相应类型提供具有对应运算符指定名称的成员函数，当前的类对象直接作为运算符左边的操作数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="comment">//重载&quot;+&quot;运算符</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Student</span>)</span></span>: Student &#123;</span><br><span class="line">        <span class="keyword">return</span> Student(name + other.name, age + other.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stu1 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> stu2 = Student(<span class="string">&quot;Jerry&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">val</span> stu3 = stu1 + stu2    <span class="comment">// stu1.plus(stu2)</span></span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;stu3.name&#125;</span>: <span class="subst">$&#123;stu3.age&#125;</span>&quot;</span>)    <span class="comment">// TomJerry: 41</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运算符对应的名称是固定的。</strong></p>
<p>下面是基本的一元运算符的固定名称。</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>+a</code></td>
<td align="center"><code>a.unaryPlus()</code></td>
</tr>
<tr>
<td align="center"><code>-a</code></td>
<td align="center"><code>a.unaryMinus()</code></td>
</tr>
<tr>
<td align="center"><code>!a</code></td>
<td align="center"><code>a.not()</code></td>
</tr>
<tr>
<td align="center"><code>a++</code></td>
<td align="center"><code>a.dec()</code></td>
</tr>
<tr>
<td align="center"><code>a--</code></td>
<td align="center"><code>a.inc()</code></td>
</tr>
</tbody></table>
<p><code>inc()</code>和<code>dec()</code>函数比较特殊，他们返回新生成的对象，将变量的值直接引用到这个对象。</p>
<p>例如，<code>a++</code>的操作步骤如下：</p>
<ul>
<li>将<code>a</code>的初始值存储到临时对象<code>a0</code>;</li>
<li>将<code>a0.inc()</code>的结果分配给a;</li>
<li>返回<code>a0</code>作为表达式的结果。</li>
</ul>
<p>同理，<code>++a</code>的操作步骤如下：</p>
<ul>
<li>将<code>a.inc()</code>的结果分配给a;</li>
<li>作为表达式的结果返回<code>a</code>的新值。</li>
</ul>
<p>下面是基本的二元运算符的固定名称。</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>a + b</code></td>
<td align="center"><code>a.plus(b)</code></td>
</tr>
<tr>
<td align="center"><code>a - b</code></td>
<td align="center"><code>a.minus(b)</code></td>
</tr>
<tr>
<td align="center"><code>a * b</code></td>
<td align="center"><code>a.times(b)</code></td>
</tr>
<tr>
<td align="center"><code>a / b</code></td>
<td align="center"><code>a.div(b)</code></td>
</tr>
<tr>
<td align="center"><code>a % b</code></td>
<td align="center"><code>a.rem(b)</code></td>
</tr>
<tr>
<td align="center"><code>a .. b</code></td>
<td align="center"><code>a.rangeTo(b)</code></td>
</tr>
<tr>
<td align="center"><code>a ..&lt; b</code></td>
<td align="center"><code>a.rangeUntil(b)</code></td>
</tr>
<tr>
<td align="center"><code>a in b</code></td>
<td align="center"><code>b.contains(a)</code></td>
</tr>
<tr>
<td align="center"><code>a !in b</code></td>
<td align="center"><code>!b.contains(a)</code></td>
</tr>
</tbody></table>
<p><strong>对于<code>in</code>来说，返回值必须是Boolean类型。</strong></p>
<p>运算符重载有可能会出现歧义。对于<code>a = a + b</code>和<code>a + = b</code>来说，两者的功能基本一致，如果同时重载了<code>plus()</code>和<code>plusAssign()</code>，编译器会不知道用哪个，因此会出现歧义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Student</span>)</span></span>: Student &#123;</span><br><span class="line">    <span class="keyword">return</span> Student(name + other.name, age + other.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plusAssign</span><span class="params">(other: <span class="type">Student</span>)</span></span> &#123;</span><br><span class="line">    name += other.name</span><br><span class="line">    age += other.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个运算符都能匹配到下方的使用，因此会报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/kotlin/Kotlin-Tutorial/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%A4%9A%E4%B9%89%E6%80%A7.png" alt="赋值运算符多义性"></p>
<p>比较运算符只需要实现一个即可。</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">名称</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>a &gt; b</code></td>
<td align="center"><code>a.compareTo(b) &gt; 0</code></td>
</tr>
<tr>
<td align="center"><code>a &lt; b</code></td>
<td align="center"><code>a.compareTo(b) &lt; 0</code></td>
</tr>
<tr>
<td align="center"><code>a &gt;= b</code></td>
<td align="center"><code>a.compareTo(b) &gt;= 0</code></td>
</tr>
<tr>
<td align="center"><code>a &lt;= b</code></td>
<td align="center"><code>a.compareTo(b) &lt;= 0</code></td>
</tr>
</tbody></table>
<p>所有的比较都会转为<code>compareTo()</code>进行调用，返回<code>Int</code>类型的值用于判断是否满足条件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">Student</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age.compareTo(other.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> stu1 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">val</span> stu2 = Student(<span class="string">&quot;Jerry&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    println(stu1 &gt;= stu2)    <span class="comment">// 20 - 21 &lt; 0 返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin非常强大，甚至连<code>()</code>和<code>[]</code>也可以重载。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>a()</code></td>
<td><code>a.invoke()</code></td>
</tr>
<tr>
<td><code>a(i)</code></td>
<td><code>a.invoke(i)</code></td>
</tr>
<tr>
<td><code>a(i, j)</code></td>
<td><code>a.invoke(i, j)</code></td>
</tr>
<tr>
<td><code>a(i_1, i_2, ..., i_n)</code></td>
<td><code>a.invoke(i_1, i_2, ..., i_n)</code></td>
</tr>
<tr>
<td><code>a[i]</code></td>
<td><code>a.get(i)</code></td>
</tr>
<tr>
<td><code>a[i, j]</code></td>
<td><code>a.get(i, j)</code></td>
</tr>
<tr>
<td><code>a[i_1, i_2, ..., i_n]</code></td>
<td><code>a.get(i_1, i_2, ..., i_n)</code></td>
</tr>
<tr>
<td><code>a[i] = b</code></td>
<td><code>a.set(i, b)</code></td>
</tr>
<tr>
<td><code>a[i, j] = b</code></td>
<td><code>a.set(i, j, b)</code></td>
</tr>
<tr>
<td><code>a[i_1, i_2, ..., i_n] = b</code></td>
<td><code>a.set(i_1, i_2, ..., i_n)</code></td>
</tr>
</tbody></table>
<h3 id="空值和空类型"><a href="#空值和空类型" class="headerlink" title="空值和空类型"></a>空值和空类型</h3><p>在Kotlin中，对空值处理非常严格。正常情况下我们不能直接给变量赋值为<code>null</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/kotlin/Kotlin-Tutorial/%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BCnull.png" alt="不能直接赋值null"></p>
<p>可以通过在类型后面添加<code>?</code>使其变为可空类型，使该变量在初始情况下使用<code>null</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 为了安全起见，需要对可空变量进行判断，然后才能正常使用</span></span><br><span class="line"><span class="keyword">if</span>(name != <span class="literal">null</span>)&#123;</span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们已经清楚该变量在某情况下一定不为空，我们可以通过非空断言操作符<code>!!.</code>来告诉编译器一定是安全的，可以执行。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="literal">null</span></span><br><span class="line">println(name!!.length)</span><br></pre></td></tr></table></figure>

<p>Kotlin提供了一种更安全的空类型操作，使用安全调用运算符<code>?.</code>来安全的使用对象，如果对象的属性为<code>null</code>则安全调用运算符返回<code>null</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 如果str为null，得到的结果就是null，不会执行后面的操作</span></span><br><span class="line"><span class="comment">// 如果str不为null，则正常执行</span></span><br><span class="line">println(name?.length)</span><br></pre></td></tr></table></figure>

<p>如果想让安全调用运算符返回一个自定义的结果而不是<code>null</code>，可以使用Elvis运算符<code>?:</code>。如果Elvis左侧为<code>null</code>，则返回右侧的自定义结果。</p>
<p><em>Elvis运算符有点像三元运算符，但不是同样的作用。</em></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">val</span> len: <span class="built_in">Int</span> = name?.length ?: -<span class="number">1</span>    <span class="comment">// 如果name为null，则返回-1</span></span><br></pre></td></tr></table></figure>

<h3 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h3><p>在使用对象时可能需要访问对象内部的一些属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stu = Student(<span class="string">&quot;Soria&quot;</span>, <span class="number">18</span>)</span><br><span class="line">println(<span class="string">&quot;<span class="subst">$&#123;stu.name&#125;</span>: <span class="subst">$&#123;stu.age&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样的操作不太优雅，我们可以通过解构的方式对属性进行处理。</p>
<p>要让一个类的属性支持解构，只需要添加约定的函数即可。在Kotlin中可以自定义解构出来的结果，通过定义<code>componentN()</code>并通过返回值的形式返回解构结果。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>)&#123;</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span> = name</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> stu = Student(<span class="string">&quot;Soria&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    <span class="keyword">val</span> (a, b) = stu</span><br><span class="line">    println(<span class="string">&quot;<span class="subst">$&#123;a&#125;</span>: <span class="subst">$&#123;b&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>当我们指定一个类、方法或属性的修改或者重写权限时，需要用到<strong>限制修饰符</strong>。在Kotlin中，类的默认修饰符为<code>final</code>，因此类和方法默认是不可被继承或重写的。我们可以通过<code>open</code>修饰符使其可以被继承和重写。</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">含义</th>
<th align="center">与java比较</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>open</code></td>
<td align="center">允许被继承或重写</td>
<td align="center">相当于java类与方法的默认情况</td>
</tr>
<tr>
<td align="center"><code>abstract</code></td>
<td align="center">抽象类或抽象方法</td>
<td align="center">与java一致</td>
</tr>
<tr>
<td align="center"><code>final</code></td>
<td align="center">不允许被继承或重写(默认情况)</td>
<td align="center">与java主动指定<code>final</code>的效果一致</td>
</tr>
</tbody></table>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can fly.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Eagle</span> : <span class="type">Bird</span>() &#123; </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I can also fly.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  [!NOTE]</p>
<p>  实际过程中应遵循<strong>里氏替换原则</strong>，子类可以扩展父类的功能，但不能改变父类原有的功能。包含以下四个设计原则：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li>
<li>子类可以增加自己特有的方法；</li>
<li>子类的方法实现父类的方法时，形参应比父类的输入参数更宽松；</li>
<li>子类的方法实现父类的抽象方法时，返回值要比父类更严格。</li>
</ul>
</blockquote>
<p>Kotlin还可以通过<code>sealed</code>关键字修饰一个类为<strong>密封类</strong>，若要继承则需要将子类定义在同一个文件中，其他文件中的类无法继承这个类。</p>
<p>密封类是基于一个抽象类实现的，因此<strong>密封类不能被初始化</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">fly</span><span class="params">()</span></span> = println(<span class="string">&quot;I can fly.&quot;</span>)</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Eagle</span> : <span class="type">Bird</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过可见性修饰符可以指定类、方法及属性的可见性。Kotlin的可见性修饰符与java类似，但仍有几点不同：</p>
<ul>
<li>Kotlin中默认修饰符为<code>public</code>，而java中是<code>default</code>；</li>
<li>Kotlin可以在一个文件内单独声明方法及常量，同样支持可见性修饰符；</li>
<li>java中除了内部类以外，其他类不允许使用<code>private</code>修饰，Kotlin可以；</li>
<li>Kotlin中的<code>protected</code>修饰符只允许类和子类能访问，而java中的包也可以访问；</li>
<li>Kotlin中的独特修饰符<code>internal</code>，叫做模块内访问。被<code>internal</code>修饰的类，别人在引用我们的项目时不可访问。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个项目模块都可以访问该类，但别人用我们的项目作为第三方库时无法访问</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">School</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> identify: String</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">val</span> name: String = <span class="string">&quot;School&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> date: String = <span class="string">&quot;2024-01-01&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">School</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> identify: String = <span class="string">&quot;student&quot;</span></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(identify)</span><br><span class="line">        <span class="comment">// name被protected修饰，允许其子类访问</span></span><br><span class="line">        println(<span class="keyword">super</span>.name)</span><br><span class="line">        <span class="comment">// date被private修饰，无法访问，此处会报错</span></span><br><span class="line">        println(<span class="keyword">super</span>.date)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的封装和继承"><a href="#类的封装和继承" class="headerlink" title="类的封装和继承"></a>类的封装和继承</h2><p>封装的目的是为了保证变量的安全性，使我们不必在意具体实现细节，只通过外部接口即可访问类的成员。如果不进行封装，类中的实例变量可以直接查看和修改，会给整个程序带来不好的影响。在编写类时，一般将成员变量私有化，外部类需要通过<code>Getter</code>和<code>Setter</code>进行查看和设置变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">private</span> <span class="keyword">var</span> name: String, <span class="keyword">private</span> <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getName</span><span class="params">()</span></span>: String &#123; <span class="keyword">return</span> name &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getAge</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123; <span class="keyword">return</span> age &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setName</span><span class="params">(name: <span class="type">String</span>)</span></span> &#123; <span class="keyword">this</span>.name = name &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setAge</span><span class="params">(age: <span class="type">Int</span>)</span></span> &#123; <span class="keyword">this</span>.age = age &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin中的继承和实现接口没有采用<code>extends</code>和<code>implements</code>关键字，<strong>而是使用”:”来代替</strong>。</p>
<p>如果父类存在一个有参构造函数，子类必须在构造函数中调用。如果父类存在多个构造函数，则可以任选一个。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name: String) : <span class="keyword">this</span>(name, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">me</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">private</span> <span class="keyword">val</span> grade: <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">me</span><span class="params">()</span></span> = println(<span class="string">&quot;Student, <span class="variable">$name</span>, <span class="variable">$age</span>, in grade <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(name: String, <span class="keyword">private</span> <span class="keyword">val</span> subject: String) : Person(name) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">me</span><span class="params">()</span></span> = println(<span class="string">&quot;Teacher, <span class="variable">$name</span>, teach <span class="variable">$subject</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student1 = Student(<span class="string">&quot;John&quot;</span>, <span class="number">18</span>, <span class="number">12</span>)</span><br><span class="line">    student1.me()    <span class="comment">// Student, John, 18, in grade 12.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> teacher1 = Teacher(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;Math&quot;</span>)</span><br><span class="line">    teacher1.me()    <span class="comment">// Teacher, Mary, teach Math.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>和java一样，在Kotlin中也是用<code>override</code>关键字来重写对象。但需要注意的是，被重写的对象需要用<code>open</code>关键字修饰。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Student</span>() &#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">(subject: <span class="type">String</span>)</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Soria</span>:<span class="type">Student</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">(subject: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Soria is studying <span class="variable">$subject</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> soria:Student = Soria()</span><br><span class="line">    soria.study(<span class="string">&quot;Math&quot;</span>)    <span class="comment">// Soria is studying Math</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>在Kotlin中声明内部类，必须用<code>inner</code>关键字修饰这个类，若没有修饰则会被视为嵌套类。</p>
<p>内部类包含对其外部类实例的引用，可以使用外部类中的属性。而嵌套类不包含，所以无法调用外部类的属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name = <span class="string">&quot;ErrorInner&quot;</span></span><br><span class="line">    <span class="comment">// 这是嵌套类并非内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ErrorInnerClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// name变量无法被访问到</span></span><br><span class="line">            println(name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> name2 = <span class="string">&quot;CorrectInner&quot;</span></span><br><span class="line">    <span class="comment">// 正确的内部类</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">CorrectInnerClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// name变量可以被访问</span></span><br><span class="line">            println(name2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类的内部可以定义多个内部类，每个内部类的实例都有自己独立的状态，与外部对象的信息相互独立。利用<code>private</code>修饰内部类，可以使其他类都不能访问内部类，具有良好的封装性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Horse</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Horse is running fast.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Donkey</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pack</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Donkey can pack lots of things.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mule</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">HorseTest</span>:<span class="type">Horse</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">inner</span> <span class="keyword">class</span> <span class="title class_">DonkeyTest</span>:<span class="type">Donkey</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123; HorseTest().run() &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">pack</span><span class="params">()</span></span> &#123; DonkeyTest().pack() &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>Kotlin中的枚举和java相同，但是声明是要通过<code>enum class</code>的方式声明。</p>
<p>枚举类可以具有成员。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">LightState</span>(<span class="keyword">val</span> color: String) &#123;</span><br><span class="line">    RED(<span class="string">&quot;红灯&quot;</span>),</span><br><span class="line">    YELLOW(<span class="string">&quot;黄灯&quot;</span>),</span><br><span class="line">    GREEN(<span class="string">&quot;绿灯&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isGreen</span><span class="params">()</span></span> = <span class="keyword">this</span> == GREEN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> light = LightState.GREEN</span><br><span class="line">    <span class="keyword">if</span> (light.isGreen()) print(<span class="string">&quot;可以通行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类还提供了很多方法用于我们快速使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过valueOf以字符串形式转化为对应名称的枚举</span></span><br><span class="line"><span class="keyword">val</span> state = LightState.valueOf(<span class="string">&quot;RED&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> state = enumValueOf&lt;LightState&gt;(<span class="string">&quot;RED&quot;</span>)</span><br><span class="line"><span class="comment">// 枚举在第几个位置</span></span><br><span class="line">state.ordinal</span><br><span class="line"><span class="comment">// 枚举名称</span></span><br><span class="line">state.name</span><br><span class="line"><span class="comment">// 获取全部枚举，得到的结果是List的子接口EnumEntries类型，因此可以当做List使用</span></span><br><span class="line"><span class="keyword">val</span> entries = LightState.entries</span><br><span class="line"><span class="keyword">val</span> values: Array&lt;LightState&gt; = enumValues&lt;LightState&gt;()</span><br></pre></td></tr></table></figure>

<h3 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h3><p>我们可以通过<code>data class</code>声明一个数据类。声明一个数据类必须满足以下条件：</p>
<ul>
<li>必须拥有一个构造方法，该方法至少包含一个参数；</li>
<li>构造方法的参数强制使用var或val进行声明；</li>
<li>data class前不能用abstract、open、sealed或inner进行修饰。</li>
</ul>
<p>数据类既可以实现接口也可以继承类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> food: String)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating <span class="variable">$food</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> animal = Animal(<span class="string">&quot;Lion&quot;</span>, <span class="string">&quot;Meat&quot;</span>)</span><br><span class="line">    animal.eat()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> (nameP, foodP) = Pair(<span class="string">&quot;Sheep&quot;</span>, <span class="string">&quot;Grass&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$nameP</span> is eating <span class="variable">$foodP</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kotlin提供了<code>Pair</code>和<code>Triple</code>两个数据类，前者有两个属性，后者有三个，让使用者不必主动声明数据类。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>有时候我们设计的类仅仅是作为给其他类集成使用的类，其本身不需要创建任何实例对象。通过<code>abstract</code>关键字可以将一个类声明为抽象类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> type: String</span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">me</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="type">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> type: String = <span class="string">&quot;student&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">me</span><span class="params">()</span></span> = println(<span class="string">&quot;I am <span class="variable">$type</span>.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="type">Person</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> type: String = <span class="string">&quot;teacher&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">me</span><span class="params">()</span></span> = println(<span class="string">&quot;I am <span class="variable">$type</span>, and I teach students.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类不仅可以具有抽象的属性，同时也具有普通类的性质，同样可以定义非抽象的属性或函数。同时，抽象类也可以继承自其他的类（可以是抽象类也可以是普通类）。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口只能包含函数或属性的定义，所有的内容默认用<code>abstract</code>修饰。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> name: String</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">// 为了应对需求，接口也可以编写默认实现</span></span><br><span class="line">    <span class="comment">// 默认情况为open，可以用private修饰掉</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sleep</span><span class="params">()</span></span> = println(<span class="string">&quot;I am sleeping&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> : <span class="type">Student</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> name: String = <span class="string">&quot;John&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">study</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;I am studying&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person()</span><br><span class="line">    person.study()</span><br><span class="line">    person.sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>通过<code>companion object</code>关键字可以创建伴生对象。伴生对象和java中<code>static</code>的修饰效果性质一样，且全局只有一个单例。伴生对象需要声明在类的内部，在类被装载时会被初始化。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Prize</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> PRIZES = arrayOf(<span class="string">&quot;一等奖&quot;</span>, <span class="string">&quot;二等奖&quot;</span>, <span class="string">&quot;三等奖&quot;</span>)</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getPrize</span><span class="params">(index: <span class="type">Int</span>)</span></span>: String &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">if</span> (index <span class="keyword">in</span> <span class="number">1.</span><span class="number">.3</span>)</span><br><span class="line">                PRIZES[index - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="string">&quot;未中奖&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 一等奖</span></span><br><span class="line">    println(Prize.getPrize(<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="object单例"><a href="#object单例" class="headerlink" title="object单例"></a>object单例</h3><p>单例模式最大的特点是系统中只能存在一个实例对象，所以在java中必须设置构造方法私有化，以及提供静态方法创建实例的方式来创建实例对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">DatabaseConfig</span> <span class="variable">databaseConfig</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_PORT</span> <span class="operator">=</span> <span class="number">3306</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DatabaseConfig</span><span class="params">(String host, <span class="type">int</span> port, String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">        <span class="built_in">this</span>.port = port;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> DatabaseConfig <span class="title function_">getdatabaseConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (databaseConfig != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> databaseConfig;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DatabaseConfig</span>(DEFAULT_HOST, DEFAULT_PORT, DEFAULT_USERNAME, DEFAULT_PASSWORD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是java实现一个最基本单例模式的精简例子（省略了多线程以及多种参数创建单例对象的方法）。它依赖<code>static</code>关键字，同时还必须将构造方法私有化。</p>
<p>在Kotlin中，通过<code>object</code>关键字可以直接实现单例。<code>object</code>的全局声明对象只有一个，所以并不需要语法上的初始化，甚至不需要构造方法。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DatabaseConfig &#123;</span><br><span class="line">    <span class="keyword">var</span> host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    <span class="keyword">var</span> port = <span class="number">3306</span></span><br><span class="line">    <span class="keyword">var</span> username = <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="keyword">var</span> password = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过var修饰的属性，我们还可以修改它们</span></span><br><span class="line">    DatabaseConfig.host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">    DatabaseConfig.port = <span class="number">3307</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>object</code>还可以代替java的匿名内部类。例如，通过java对字符串列表进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>);</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在Kotlin中，可以通过<code>object</code>表达式对其进行改善。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: List&lt;String&gt; = listOf(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> comparator = <span class="keyword">object</span> : Comparator&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compare</span><span class="params">(o1: <span class="type">String</span>?, o2: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(list, comparator)</span><br></pre></td></tr></table></figure>

<p>在java中，匿名内部类只能继承一个类以及实现一个接口，而<code>object</code>表达式没有这个限制。而且<code>object</code>表达式在运行时并不会全局只存在一个对象，而是每次运行时都会生成一个新的对象。</p>
<p>我们还可以将上面的代码通过Lambda表达式改造一下。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> comparator = Comparator&lt;String&gt; &#123; o1, o2 -&gt;</span><br><span class="line">    <span class="keyword">if</span> (o1 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Comparator</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (o2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@Comparator</span> <span class="number">1</span></span><br><span class="line">    o1.compareTo(o2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当只需要实现一个方法时，使用Lambda表达式更适合；当匿名内部类内有多个方法需要实现时，使用<code>object</code>表达式更加合适。</strong></p>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p>在Kotlin中，处理NPE(NullPointerException)非常容易。Kotlin能够很好的区分非空类型和可空类型。在Kotlin中访问非空类型的变量永远不会抛出空指针异常。</p>
<p>具体见上一章节。</p>
<h3 id="通过Either代替可空类型"><a href="#通过Either代替可空类型" class="headerlink" title="通过Either代替可空类型"></a>通过<code>Either</code>代替可空类型</h3><p><code>Either</code>类型只有<code>Left</code>和<code>Right</code>两个子类型。通常来说<code>Left</code>代表出错的情况，<code>Right</code>代表正确的情况。如果<code>Either[A, B]</code>对象包含的是A的实例，它就是<code>Left</code>实例，否则就是<code>Right</code>实例。</p>
<p>在Kotlin中并没有<code>Either</code>类，但是可以通过密封类便捷的创造出<code>Either</code>类。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Either</span>&lt;<span class="type">A, B</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Left</span>&lt;<span class="type">A, B</span>&gt;(<span class="keyword">val</span> value: A) : Either&lt;A, B&gt;()</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Right</span>&lt;<span class="type">A, B</span>&gt;(<span class="keyword">val</span> value: B) : Either&lt;A, B&gt;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 眼镜，眼镜一定有度数</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Glasses</span>(<span class="keyword">val</span> degreeOfMyopia: <span class="built_in">Int</span>)</span><br><span class="line"><span class="comment">// 学生，学生可能戴着眼镜</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Student</span>(<span class="keyword">val</span> glasses: Glasses?)</span><br><span class="line"><span class="comment">// 座位，座位上可能有学生</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Seat</span>(<span class="keyword">val</span> student: Student?)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getDegreeOfMyopia</span><span class="params">(seat: <span class="type">Seat</span>?)</span></span>:Either&lt;Error,<span class="built_in">Int</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> seat?.student?.glasses?.let&#123; Either.Right(it.degreeOfMyopia)&#125;?:Either.Left(Error(<span class="string">&quot;No student or glasses found&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  [!NOTE]</p>
<p>  <code>let</code>的概念</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R = block(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<p>  调用某对象的<code>let</code>函数，该对象会作为函数的参数，在函数块内可通过<code>it</code>代指该对象。返回值为函数的最后一行或指定的<code>return</code>表达式。</p>
</blockquote>
<p>按照上述写法代码量会变多，但是我们需要用ADT更好地组织业务。定义一个Error类，将所有步骤中的错误都抽象为不同的子类型，便于最终的处理以及后期排查错误。</p>
<h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>在Kotlin中，可以通过<code>is</code>关键字判断一个对象是什么类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">is</span> String)&#123;</span><br><span class="line">	println(obj.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">is</span> String -&gt; println(obj.length)</span><br><span class="line">    !<span class="keyword">is</span> String -&gt; println(<span class="string">&quot;Not a String&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述obj为<code>Any</code>类型，虽然做了类型判断，但是在没有类型转换的前提下，我们直接使用了<code>length</code>方法。这主要通过智能类型转换实现。</p>
<h2 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h2><p>智能类型转换时隐式完成的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stu:Student = Student(Glasses(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">if</span>(stu.glasses!= <span class="literal">null</span>) println(stu.glasses.degreeOfMyopia)</span><br></pre></td></tr></table></figure>

<p>Kotlin和其他语言一样，无法直接将父类型转化为子类型。当类型需要强制转换时，可以通过<code>as</code>关键字实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Human</span> <span class="title">data</span> <span class="title">class</span> <span class="title">Teacher</span>(<span class="keyword">val</span> name:String) :Human()</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTeacher</span><span class="params">()</span></span>:Human = Teacher(<span class="string">&quot;John&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> teacher = getTeacher() <span class="keyword">as</span> Teacher</span><br><span class="line">println(teacher.name)</span><br><span class="line"><span class="comment">// 也可以这么写</span></span><br><span class="line"><span class="comment">// val teacher = getTeacher()</span></span><br><span class="line"><span class="comment">// teacher as Teacher</span></span><br></pre></td></tr></table></figure>

<p><code>as</code>是不安全的类型转换，一般使用<code>as?</code>，如果对象为空则返回<code>null</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> teacher = getTeacher() <span class="keyword">as</span>? Teacher</span><br><span class="line"><span class="keyword">if</span>(teacher != <span class="literal">null</span>)&#123;</span><br><span class="line">    println(teacher.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Any和Any-类型"><a href="#Any和Any-类型" class="headerlink" title="Any和Any?类型"></a>Any和Any?类型</h2><h3 id="Any类型"><a href="#Any类型" class="headerlink" title="Any类型"></a>Any类型</h3><p><strong><code>Any</code>类型式<u>非空类型</u>的根类型。</strong>如果定义了一个没有指定父类型的类型，则该类型将是Any类型的直接子类型。如果为定义的新类型指定了父类型，则该父类型将是新类型的直接父类型，但新类型的最终根类型仍为<code>Any</code>。</p>
<p>如果新类型实现了多个接口，那么将具有多个直接的父类型，但最终根类型还是<code>Any</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="keyword">val</span> weight:<span class="built_in">Double</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span>(weight:<span class="built_in">Double</span>,<span class="keyword">val</span> swimSpeed:<span class="built_in">Double</span>):Animal(weight)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CanFly</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BuildNest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>(weight:<span class="built_in">Double</span>,<span class="keyword">val</span> flySpeed:<span class="built_in">Double</span>):Animal(weight),CanFly,BuildNest</span><br></pre></td></tr></table></figure>

<p>Kotlin把java方法参数和返回类型中的<code>Object</code>类型看作是<code>Any</code>（又或者是<em>平台类型</em>）。当Kotlin在函数中使用<code>Any</code>时，会被编译成java字节码中的Object。</p>
<blockquote>
<p>  [!NOTE]</p>
<p>  平台类型本质上是Kotlin不知道可空性信息的类型。所有java引用类型都在Kotlin中表现为平台类型。当在Kotlin中处理平台类型的值的时候，它既可以被当做可空类型来处理，也可以被当做非空类型来处理。</p>
</blockquote>
<h3 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any?类型"></a>Any?类型</h3><p><code>Any?</code>是<code>Any</code>的父类型，而且**<code>Any?</code>类型是<u>所有类型</u>的根类型。**</p>
<p><code>Any?</code>可以看作是<code>Any∪null</code>。</p>
<h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p>Kotlin没有int、float等原始类型，而是Int、Float等引用类型包装类。用java举例，Kotlin中的<code>Int</code>相当于<code>int</code>，<code>Int?</code>相当于<code>Integer</code>。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在Kotlin中，数组是一个<code>Array</code>类型的对象。<strong>数组在创建完成之后，数组容量和元素类型是固定不变的，后续无法进行修改。</strong>数组在内存中是连续的，所以性能比较好。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 原生类型数组，对应java中的double[]、short[]等</span></span><br><span class="line"><span class="keyword">val</span> arr2 = doubleArrayOf(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>)</span><br><span class="line"><span class="keyword">val</span> arr3 = shortArrayOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> arr4 = charArrayOf(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="数组的打印"><a href="#数组的打印" class="headerlink" title="数组的打印"></a>数组的打印</h3><p>Kotlin提供了很多种打印数组的方式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 基本的for循环</span></span><br><span class="line"><span class="comment">// 1,2,3,4,5</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0.</span>.&lt;arr.size) &#123; print(<span class="string">&quot;<span class="subst">$&#123;arr[i]&#125;</span>,&quot;</span>) &#125;</span><br><span class="line">println(<span class="string">&quot;\b&quot;</span>)</span><br><span class="line"><span class="comment">// 增强for循环</span></span><br><span class="line"><span class="comment">// 1,2,3,4,5</span></span><br><span class="line"><span class="keyword">for</span> (element <span class="keyword">in</span> arr) &#123; print(<span class="string">&quot;<span class="subst">$&#123;element&#125;</span>,&quot;</span>) &#125;</span><br><span class="line">println(<span class="string">&quot;\b&quot;</span>)</span><br><span class="line"><span class="comment">// 使用withIndex解构后可同时遍历索引和值</span></span><br><span class="line"><span class="comment">// 0 -&gt; 1,1 -&gt; 2,2 -&gt; 3,3 -&gt; 4,4 -&gt; 5</span></span><br><span class="line"><span class="keyword">for</span> ((index, value) <span class="keyword">in</span> arr.withIndex()) &#123; print(<span class="string">&quot;<span class="variable">$index</span> -&gt; <span class="variable">$value</span>,&quot;</span>) &#125;</span><br><span class="line">println(<span class="string">&quot;\b&quot;</span>)</span><br><span class="line"><span class="comment">// forEach高阶函数</span></span><br><span class="line"><span class="comment">// 1,2,3,4,5</span></span><br><span class="line">arr.forEach &#123; print(<span class="string">&quot;<span class="variable">$it</span>,&quot;</span>) &#125;</span><br><span class="line">println(<span class="string">&quot;\b&quot;</span>)</span><br><span class="line"><span class="comment">// forEachIndexed高阶函数，可以同时遍历索引和值</span></span><br><span class="line"><span class="comment">// 0 -&gt; 1,1 -&gt; 2,2 -&gt; 3,3 -&gt; 4,4 -&gt; 5</span></span><br><span class="line">arr.forEachIndexed &#123; index, value -&gt; print(<span class="string">&quot;<span class="variable">$index</span> -&gt; <span class="variable">$value</span>,&quot;</span>) &#125;</span><br><span class="line">println(<span class="string">&quot;\b&quot;</span>)</span><br><span class="line"><span class="comment">// joinToString将数组转化为字符串的形式，默认用&quot;,&quot;隔开每个元素</span></span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line">println(arr.joinToString())</span><br><span class="line"><span class="comment">// 自定义joinToString返回的结果形式</span></span><br><span class="line"><span class="comment">// 2, 4, 6, 8, 10</span></span><br><span class="line">println(arr.joinToString &#123; (it * <span class="number">2</span>).toString() &#125;)</span><br><span class="line"><span class="comment">// 自定义joinToString的分隔符、前缀和后缀</span></span><br><span class="line"><span class="comment">// &#123;1-2-3-4-5&#125;</span></span><br><span class="line">println(arr.joinToString(separator = <span class="string">&quot;-&quot;</span>, prefix = <span class="string">&quot;&#123;&quot;</span>, postfix = <span class="string">&quot;&#125;&quot;</span>))</span><br><span class="line"><span class="comment">// 限制joinToString输出的元素个数为limit，并用truncated的内容表示剩余的元素</span></span><br><span class="line"><span class="comment">// 1, 2, ...</span></span><br><span class="line">println(arr.joinToString(limit = <span class="number">2</span>, truncated = <span class="string">&quot;...&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组与java类似。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> arr = arrayOf(intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), intArrayOf(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), intArrayOf(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>))</span><br><span class="line"><span class="comment">// 建立存放5个IntArray的数组, 每个IntArray的长度为3, 用0填充</span></span><br><span class="line"><span class="keyword">val</span> arr2 = Array(<span class="number">5</span>) &#123; IntArray(<span class="number">3</span>)&#123;<span class="number">0</span>&#125; &#125;</span><br><span class="line"><span class="comment">// 内层使用Any类型就可以接收所有类型的嵌套数组</span></span><br><span class="line"><span class="keyword">val</span> arr3: Array&lt;Array&lt;<span class="keyword">out</span> Any&gt;&gt; = arrayOf(arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), arrayOf(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>Kotlin的泛型和java相同，都通过<code>&lt;&gt;</code>表示。</p>
<h3 id="类型上界"><a href="#类型上界" class="headerlink" title="类型上界"></a>类型上界</h3><p>约束一个泛型类只接受一个类型的对象或者类及其子类，称为上界约束。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Fruit</span>(<span class="keyword">val</span> weight: <span class="built_in">Double</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>(weight: <span class="built_in">Double</span>): Fruit(weight)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Banana</span>(weight: <span class="built_in">Double</span>): Fruit(weight)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Noodles</span>(weight: <span class="built_in">Double</span>)</span><br><span class="line"><span class="comment">// 这里的T只能是Fruit类及其子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FruitPlate</span>&lt;<span class="type">T: Fruit</span>&gt;(<span class="keyword">val</span> t: T)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">val</span> applePlate = FruitPlate(Apple(<span class="number">100.0</span>))</span><br><span class="line"><span class="comment">// 不允许</span></span><br><span class="line"><span class="keyword">val</span> noodlesPlate = FruitPlate(Noodles(<span class="number">100.0</span>))</span><br></pre></td></tr></table></figure>

<p>在Kotlin中，可以通过<code>where</code>关键字对泛型参数类型添加多个约束条件。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Ground</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Fruit</span>(weight:<span class="built_in">Double</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watermelon</span>(weight:<span class="built_in">Double</span>): Fruit(weight), Ground</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>(weight: <span class="built_in">Double</span>): Fruit(weight)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">cut</span><span class="params">(fruit: <span class="type">T</span>)</span></span> <span class="keyword">where</span> T: Fruit, T: Ground &#123;</span><br><span class="line">    print(<span class="string">&quot;You can cut me.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 类型匹配</span></span><br><span class="line">    cut(Watermelon(<span class="number">10.0</span>))</span><br><span class="line">    <span class="comment">// 类型不匹配，不允许</span></span><br><span class="line">    cut(Apple(<span class="number">10.0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>泛型的类型检查仅仅只存在于编译阶段，在编译之后并不会保留任何关于泛型的内容。这便是类型擦除。类型擦除后一般为<code>Any?</code>，如果存在上界，那么擦除后是上界的类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeClear</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">private</span> <span class="keyword">val</span> t: T) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isType</span><span class="params">(obj:<span class="type">Any</span>)</span></span>:<span class="built_in">Boolean</span>&#123;</span><br><span class="line">        <span class="comment">// 编译错误，由于类型擦除，运行时不存在T的类型</span></span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">is</span> T</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于内联函数，泛型擦除的处理有一些不同。内联函数的泛型参数的具体类型信息是可用的，编译一起可以使用这些信息来生成具体的字节码。</p>
<p>为了避免频繁地类型转换，通常可以配合泛型封装成一个类型转换方法。我们还要避免类型擦除，可以用<code>reified</code>修饰<code>T</code>，并在方法前用<code>inline</code>修饰。**<code>reified</code>关键字可以理解为具体化，使我们可以在方法体内访问泛型指定的JVM对象。**</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;<span class="keyword">reified</span> T&gt;</span> <span class="title">cast</span><span class="params">(original: <span class="type">Any</span>)</span></span>: T? = original <span class="keyword">as</span>? T</span><br></pre></td></tr></table></figure>

<h2 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h2><p>对于泛型来说，可以简单理解为：<strong>协变是可读不可写，逆变可写不可读。</strong>协变用<code>out</code>关键字表示，逆变用<code>in</code>关键字表示。</p>
<p>对于协变，如果类型A是类型B的子类型，那么<code>Generic&lt;A&gt;</code> 也是<code>Generic&lt;B&gt;</code>的子类型。</p>
<p>对于逆变，如果类型A是类型B的子类型，那么<code>Generic&lt;B&gt;</code> 将变为<code>Generic&lt;A&gt;</code>的子类型。</p>
<p>用<code>out</code>关键字声明的泛型参数类型将不能作为方法的参数类型，但是可以作为方法的返回值类型，对应的<code>setter</code>也会被限制。<code>in</code>关键字与<code>out</code>相反，可以作为方法的参数类型，但是不能作为方法的返回值类型，对应的<code>getter</code>也会被限制。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">var</span> <span class="keyword">data</span>:T)</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="type">A</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="type">A</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> test1:Test&lt;A&gt; = Test(B())</span><br><span class="line">    <span class="comment">// A被声明为out，setter方法被限制</span></span><br><span class="line">    <span class="keyword">val</span> test2:Test&lt;<span class="keyword">out</span> A&gt; = test1</span><br><span class="line">    test2.<span class="keyword">data</span> = C()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> test3:Test&lt;A&gt; = Test(C())</span><br><span class="line">    <span class="keyword">val</span> test4:Test&lt;<span class="keyword">in</span> C&gt; = test3</span><br><span class="line">    <span class="comment">// A被声明为in，getter方法被限制</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>:C = test3.<span class="keyword">data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<code>*</code>来代替任意类型，本质上相当于<code>out Any?</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;<span class="type">T</span>&gt;(<span class="keyword">var</span> <span class="keyword">data</span>: T)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> test1: Test&lt;String&gt; = Test(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> test2: Test&lt;*&gt; = test1</span><br></pre></td></tr></table></figure>

<h2 id="Lambda和集合"><a href="#Lambda和集合" class="headerlink" title="Lambda和集合"></a>Lambda和集合</h2><p>任何函数接收了一个java的SAM（单一抽象方法）都可以用Kotlin函数进行替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">view.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于上述java代码，我们可以看成在Kotlin中定义了以下方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// listener是一个函数类型的参数，它接收一个类型为View的参数，返回Unit</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(listener: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// 我们可以通过lambda表达式简化它</span></span><br><span class="line">view.setOnClickListener(&#123; ... &#125;)</span><br><span class="line"><span class="comment">// listener是唯一参数，可以简化掉()</span></span><br><span class="line">view.setOnClickListener&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<h3 id="带接收者的Lambda"><a href="#带接收者的Lambda" class="headerlink" title="带接收者的Lambda"></a>带接收者的Lambda</h3><p>我们可以定义带有接收者的函数类型。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum:<span class="built_in">Int</span>.(<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; other -&gt; plus(other) &#125;</span><br><span class="line"><span class="number">2.</span>sum(<span class="number">3</span>)    <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="with和apply"><a href="#with和apply" class="headerlink" title="with和apply"></a>with和apply</h3><p>Kotlin提供了<code>with</code>和<code>apply</code>两个函数，省略了需要多次书写的对象名，默认用<code>this</code>指向它。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindData</span><span class="params">(bean: <span class="type">ContentBean</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> titleTV = findViewById&lt;TextView&gt;(R.id.iv_title)</span><br><span class="line">    <span class="keyword">val</span> contentTV = findViewById&lt;TextView&gt;(R.id.iv_content)</span><br><span class="line">    <span class="comment">// with版本</span></span><br><span class="line">    with(bean)&#123;</span><br><span class="line">        titleTV.text = <span class="keyword">this</span>.title</span><br><span class="line">        contentTV.text = <span class="keyword">this</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// apply版本</span></span><br><span class="line">    bean.apply&#123;</span><br><span class="line">        titleTV.text = <span class="keyword">this</span>.title</span><br><span class="line">        contentTV.text = <span class="keyword">this</span>.content</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是<code>with</code>和<code>apply</code>在Kotlin中的定义。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R</span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T</span><br></pre></td></tr></table></figure>

<p><code>with</code>函数的第一个参数为接收者类型，然后通过第二个参数创建这个类型的block方法，因此接收者对象调用block方法时，可以直接使用<code>this</code>来代表这个对象。<code>apply</code>函数直接被声明为<code>T</code>类型的扩展方法，block参数是一个返回<code>Unit</code>类型的函数。因此，<code>with</code>的block可以返回自由的类型，然而二者在很多情况下都是可以互相替换的。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Kotlin中常用的集合包括<code>List</code>、<code>Set</code>和<code>Map</code>。</p>
<p><code>List</code>表示一个有序可重复的列表。</p>
<p><code>Set</code>表示一个不可重复的集合。<code>Set</code>的实现方式分为<code>HashSet</code>和<code>TreeSet</code>。HashSet通过Hash散列来存储元素，不能保证元素的有序性。<code>TreeSet</code>底层结构是二叉树，可以保证元素的有序性。</p>
<p><code>Map</code>和其他集合不同，没有实现<code>Iterable</code>或者<code>Collection</code>。<code>Map</code>通过键值对来表示元素。</p>
<h3 id="可变集合和有序集合"><a href="#可变集合和有序集合" class="headerlink" title="可变集合和有序集合"></a>可变集合和有序集合</h3><p>可变集合的创建方式带有mutable前缀，而只读集合一般为默认的创建方式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可变集合</span></span><br><span class="line"><span class="keyword">val</span> listArr = mutableListOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 只读集合</span></span><br><span class="line"><span class="keyword">val</span> setArr = setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">listArr[<span class="number">0</span>] = <span class="number">1</span>    <span class="comment">// 可变集合可以修改元素</span></span><br><span class="line"><span class="comment">// setArr[0] = 1    // 只读集合不能修改元素，会报错</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是每个集合类、数组都可以生成的东西，其作用是用于对内容的遍历。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> iterator = list.iterator()</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    println(iterator.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>List</code>集合来说，Kotlin提供了一个特殊的迭代器<code>listIterator</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> iterator = list.listIterator()</span><br><span class="line"><span class="comment">// 反向迭代</span></span><br><span class="line">iterator.hasPrevious()</span><br><span class="line">iterator.previous()</span><br><span class="line"><span class="comment">// 下一个元素的下标</span></span><br><span class="line">iterator.nextIndex()</span><br></pre></td></tr></table></figure>

<p>Kotlin还为Mutable集合提供了一个特殊的用于生成MutableIterator的函数，只要不是只读的集合类，都可以使用这个特殊的迭代器。其支持在遍历集合时对元素进行删除。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> it = list.iterator()</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    println(it.next())</span><br><span class="line">    it.remove()</span><br><span class="line">&#125;</span><br><span class="line">println(list)    <span class="comment">// [] 集合中元素已被删除，为空</span></span><br></pre></td></tr></table></figure>

<h3 id="惰性集合"><a href="#惰性集合" class="headerlink" title="惰性集合"></a>惰性集合</h3><p>在Kotlin中，可以通过<code>sequence</code>（序列）节省资源开销。在序列中，元素的求值是<strong>惰性</strong>的，<em>只有在需要时才进行求值，而不是在它被绑定到变量后就立刻求值。</em>（惰性求值）</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list.asSequence()</span><br><span class="line">    .filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123;</span><br><span class="line">        println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">println(list2)    <span class="comment">// kotlin.sequences.TransformingSequence@179d3b25</span></span><br></pre></td></tr></table></figure>

<p>上述操作中，<code>filter</code>和<code>map</code>中的<code>println</code>并没有被执行。</p>
<h4 id="中间操作和末端操作"><a href="#中间操作和末端操作" class="headerlink" title="中间操作和末端操作"></a>中间操作和末端操作</h4><p>在对普通集合进行链式操作的时候，有些操作会产生中间集合，当用这类操作对序列进行求值时，它们就被称为<strong>中间操作</strong>，例如上面的<code>filter</code>和<code>map</code>。这就是惰性求值的提现，也被称为延迟求值。然而，在对集合进行操作时，我们在意的大部分都是结果，而不是中间过程。末端操作就是返回结果的操作。在执行末端操作时，会触发中间操作的延迟计算。也就是满足了惰性操作的“被需要时”。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> list2 = list.asSequence()</span><br><span class="line">    .filter &#123;</span><br><span class="line">        println(<span class="string">&quot;filter: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it &gt; <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .map &#123;</span><br><span class="line">        println(<span class="string">&quot;map: <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">        it * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    .toList()</span><br><span class="line">println(list2)</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">filter: <span class="number">1</span></span><br><span class="line">filter: <span class="number">2</span></span><br><span class="line">filter: <span class="number">3</span></span><br><span class="line">map: <span class="number">3</span></span><br><span class="line">filter: <span class="number">4</span></span><br><span class="line">map: <span class="number">4</span></span><br><span class="line">filter: <span class="number">5</span></span><br><span class="line">map: <span class="number">5</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>在上述例子添加了末端操作<code>toList</code>后，所有的中间操作都被执行了。</p>
<h4 id="无限序列"><a href="#无限序列" class="headerlink" title="无限序列"></a>无限序列</h4><p>利用惰性求值的特性，可以通过序列构造出一个无限的数据类型。因为元素只有在被需要时才进行求值，所以无限序列只是实现了一种无限的状态，让我们在使用时感觉它是无限的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将自然数存储到序列中: 0, 1, 2, ..., n</span></span><br><span class="line"><span class="keyword">val</span> natureNumbers = generateSequence(<span class="number">0</span>) &#123; it + <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">val</span> list = natureNumbers.takeWhile &#123; it &lt; <span class="number">10</span> &#125;.toList()</span><br><span class="line">println(<span class="string">&quot;list = <span class="variable">$list</span>&quot;</span>)</span><br><span class="line"><span class="comment">// list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h2 id="多态和扩展"><a href="#多态和扩展" class="headerlink" title="多态和扩展"></a>多态和扩展</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>常见的多态分为子类型多态、参数多态和特设多态三种。</p>
<p>当我们用子类型去继承一个父类的时候，就是子类型多态。</p>
<h4 id="参数多态"><a href="#参数多态" class="headerlink" title="参数多态"></a>参数多态</h4><p>参数多态是指声明与定义函数、复合类型、变量时不指定其具体的类型，而是把这部分作为参数使用，使得该类型对各种具体类型都适用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">KeyI</span>&#123; <span class="keyword">val</span> uniqueKey: String &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span>(<span class="keyword">override</span> <span class="keyword">val</span> uniqueKey: String): KeyI</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>(<span class="keyword">override</span> <span class="keyword">val</span> uniqueKey: String): KeyI</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: KeyI&gt;</span> <span class="title">persist</span><span class="params">(t: <span class="type">T</span>)</span></span>&#123; </span><br><span class="line">    println(<span class="string">&quot;Persisting <span class="subst">$&#123;t.uniqueKey&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = ClassA(<span class="string">&quot;A1&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> b = ClassB(<span class="string">&quot;B1&quot;</span>)</span><br><span class="line">    persist(a)    <span class="comment">// Persisting A1</span></span><br><span class="line">    persist(b)    <span class="comment">// Persisting B1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特设多态"><a href="#特设多态" class="headerlink" title="特设多态"></a>特设多态</h4><p>对于特设多态，可以理解为一个多态函数是有多个不同的实现，依赖于其实参而调用相应版本的函数。例如函数重载、操作符重载和泛型。以上三种方式，编译器会根据传入参数的类型来选择最匹配的函数或操作符重载来执行，从而实现特设多态的效果。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>在面向对象中已经介绍了类的扩展，在此将对扩展进行详细的说明。</p>
<p>在修改现有代码时，遵循开放封闭原则，<strong>对扩展开放，对修改封闭。</strong></p>
<h4 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h4><p>扩展函数的声明非常简单，其关键字是<code>&lt;Type&gt;</code>。此外还需要一个<strong>接收者类型</strong>作为它的前缀。在扩展函数体里，可以用<code>this</code>代表接收者类型的对象。</p>
<p>以<code>MutableList&lt;Int&gt;</code>为例，我们扩展一个<code>exchange</code>方法，实现元素位置的交换。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> MutableList<span class="type">&lt;Int&gt;</span>.<span class="title">exchange</span><span class="params">(from: <span class="type">Int</span>, to: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> temp = <span class="keyword">this</span>[from]</span><br><span class="line">    <span class="keyword">this</span>[from] = <span class="keyword">this</span>[to]</span><br><span class="line">    <span class="keyword">this</span>[to] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="comment">// 交换下标为1和3的元素</span></span><br><span class="line">    list.exchange(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    println(list)    <span class="comment">// [1, 4, 3, 2, 5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><p>我们可以将扩展函数理解为java中的静态方法，独立于该类的任何对象，且不依赖类的特定实例，被该类的所有实例共享。因此<strong>扩展函数不会带来额外的性能消耗。</strong></p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>我们习惯将扩展函数直接定义在包内。</p>
<p>为了便于管理，可以将扩展函数定义在一个类内部。<em>当扩展方法定义在一个类内部时，只能在该类和其子类中进行调用。</em></p>
<h4 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h4><p>与扩展函数类似，可以为一个类添加扩展属性。</p>
<p>还是以<code>MutableList&lt;Int&gt;</code>为例，我们可以为其扩展一个判断其中元素之和是否为偶数的属性<code>sumIsEven</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> MutableList&lt;<span class="built_in">Int</span>&gt;.sumIsEven: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">this</span>.sum() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list = mutableListOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">println(list.sumIsEven)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们也可以定义类似java静态函数一样的扩展函数，但是必须将其定义在伴生对象上。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&#123; <span class="keyword">companion</span> <span class="keyword">object</span>&#123; <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">18</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Son.Companion.<span class="title">foo</span><span class="params">()</span></span> = println(<span class="string">&quot;<span class="variable">$age</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">Sun.foo()    <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>这样就可以在<code>Son</code>没有实例对象的情况下，也能调用这个扩展函数。语法类似于java的静态函数。</p>
<p>在使用扩展函数时，<strong>同名的类成员方法的优先级高于扩展函数。</strong></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>&#123; <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> = println(<span class="string">&quot;eat fruit&quot;</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">fun</span> Fruit.<span class="title">eat</span><span class="params">()</span></span> = println(<span class="string">&quot;eat apple&quot;</span>)</span><br><span class="line"></span><br><span class="line">fruit.eat()    <span class="comment">// eat fruit</span></span><br></pre></td></tr></table></figure>

<h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><p>描述数据的数据叫做元数据，操作元数据的编程就是元编程。通过元编程可以消除一些模板代码。</p>
<p>例如，我们需要将<code>data class</code>转化为<code>Map</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">USer</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">object</span> User&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">toMap</span><span class="params">(a: <span class="type">User</span>)</span></span>: Map&lt;String,Any&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> hashMapOf(<span class="string">&quot;name&quot;</span> to name, <span class="string">&quot;age&quot;</span> to age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>data class</code>比较多的情况下，就会出现大量和上面类似的样板代码。我们可以通过反射解决这个问题。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Mapper&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T: Any&gt;</span> <span class="title">toMap</span><span class="params">(a: <span class="type">T</span>)</span></span>: Map&lt;String, Any?&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a::<span class="keyword">class</span>.memberProperties.map &#123; </span><br><span class="line">            it.name to it.call(a) &#125;.toMap()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以直接写成扩展函数的形式</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : Any&gt;</span> T.<span class="title">toMap</span><span class="params">()</span></span>: Map&lt;String, Any?&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.javaClass.kotlin.memberProperties.associateBy(</span><br><span class="line">        &#123; it.name &#125;,</span><br><span class="line">        &#123; it.<span class="keyword">get</span>(<span class="keyword">this</span>) &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    <span class="keyword">val</span> map = Mapper.toMap(person)</span><br><span class="line">    <span class="comment">// val map = person.toMap()</span></span><br><span class="line">    println(map)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用反射，我们可以让上述代码适用于所有<code>data class</code>，而不需要针对每个去单独构造出一个<code>toMap</code>函数。也不需要手动创建<code>Map</code>里的属性名，可以根据KClass自动获取。</p>
<h3 id="Kotlin中的反射"><a href="#Kotlin中的反射" class="headerlink" title="Kotlin中的反射"></a>Kotlin中的反射</h3><p>先来对比一下java和Kotlin中的反射。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/kotlin/Kotlin-Tutorial/Java%E5%8F%8D%E5%B0%84.jpg" alt="Java反射"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/kotlin/Kotlin-Tutorial/Kotlin%E5%8F%8D%E5%B0%84.jpg" alt="Kotlin反射"></p>
<p>我们可以得出以下结论：</p>
<ol>
<li><code>KClass</code>和<code>Class</code>可以看做同一个含义的类型，并且可以通过<code>.java</code>和<code>.kotlin</code>方法实现两者的相互转化。</li>
<li><code>KCallable</code>和<code>AccessiableObject</code>都可以理解为可调用元素。java中的构造方法作为一个独立的类型，Kotlin则统一用<code>KFunction</code>处理。</li>
<li><code>KProperty</code>通常指相应的<code>Getter</code>和<code>Setter</code>整体作为一个<code>KProperty</code>，java的<code>Field</code>通常仅仅指字段本身。</li>
</ol>
<h3 id="KClass"><a href="#KClass" class="headerlink" title="KClass"></a>KClass</h3><p><code>KClass</code>出了和java的<code>Class</code>非常相似之外，还有独属于Kotlin的属性或方法。</p>
<table>
<thead>
<tr>
<th align="center">属性或函数</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>isCompanion</code></td>
<td align="center">是否为伴生对象</td>
</tr>
<tr>
<td align="center"><code>isData</code></td>
<td align="center">是否为数据类</td>
</tr>
<tr>
<td align="center"><code>isSealed</code></td>
<td align="center">是否为密封类</td>
</tr>
<tr>
<td align="center"><code>objectInstance</code></td>
<td align="center">object实例（如果是）</td>
</tr>
<tr>
<td align="center"><code>companionObjectInstance</code></td>
<td align="center">伴生对象实例</td>
</tr>
<tr>
<td align="center"><code>declaredMemberExtensionFunctions</code></td>
<td align="center">扩展函数</td>
</tr>
<tr>
<td align="center"><code>declaredMemberExtesionProperties</code></td>
<td align="center">扩展属性</td>
</tr>
<tr>
<td align="center"><code>memberExtensionFunctions</code></td>
<td align="center">本类及超类扩展函数</td>
</tr>
<tr>
<td align="center"><code>memberExtensionProperties</code></td>
<td align="center">本类及超类扩展属性</td>
</tr>
<tr>
<td align="center"><code>starProjectedType</code></td>
<td align="center">泛型通配类型</td>
</tr>
</tbody></table>
<p>下面通过一个例子理解上述方法或属性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">data</span> <span class="keyword">object</span> TOMCAT : Cat()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> Companion.getCat</span><br><span class="line">        <span class="keyword">get</span>() = TOMCAT</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="type">&lt;C : Cat&gt;</span> Animal<span class="type">&lt;C&gt;</span>.<span class="title">proceed</span><span class="params">()</span></span>: C = <span class="keyword">this</span>.cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&lt;<span class="type">C : Cat</span>&gt;(<span class="keyword">val</span> cat: C) : Cat()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;C : Cat&gt;</span> Cat.<span class="title">plus</span><span class="params">(other: <span class="type">C</span>)</span></span>: Cat &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">when</span> &#123;</span><br><span class="line">        other <span class="keyword">is</span> Animal&lt;*&gt; -&gt; Animal(other.cat)</span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法的调用结果如下表所示。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Cat.Companion::class.isCompanion</code></td>
<td align="center"><code>true</code></td>
</tr>
<tr>
<td align="center"><code>Cat::class.isSealed</code></td>
<td align="center"><code>true</code></td>
</tr>
<tr>
<td align="center"><code>Cat.Companion::class.objectInstance</code></td>
<td align="center"><code>包名.Cat$Companion@地址</code></td>
</tr>
<tr>
<td align="center"><code>Cat::class.declaredMemberExtensionProperties.map &#123; it.name &#125;</code></td>
<td align="center"><code>[getCat]</code></td>
</tr>
<tr>
<td align="center"><code>Cat::class.declaredMemberExtensionFunctions.map &#123; it.name &#125;</code></td>
<td align="center"><code>[proceed]</code></td>
</tr>
<tr>
<td align="center"><code>Animal::class.memberExtensionProperties.map &#123; it.name &#125;</code></td>
<td align="center"><code>[getCat]</code></td>
</tr>
<tr>
<td align="center"><code>Animal::class.memberExtensionFunctions.map &#123; it.name &#125;</code></td>
<td align="center"><code>[proceed]</code></td>
</tr>
<tr>
<td align="center"><code>Animal::class.starProjectedType</code></td>
<td align="center"><code>包名.Animal&lt;*&gt;</code></td>
</tr>
</tbody></table>
<h3 id="KCallable"><a href="#KCallable" class="headerlink" title="KCallable"></a>KCallable</h3><p>Kotlin把<code>Class</code>中的属性<code>Property</code>和函数<code>Function</code>以及构造函数都看做<code>KCallable</code>，因为它们是可调用的，都是<code>Class</code>的成员。</p>
<p>KCallAble提供了一些实用的API。这些API和java中的反射的API很相似，都是对<code>KCallable</code>（Class成员）的信息的获取。</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>isAbstract: Boolean&lt;KParameter&gt;</code></td>
<td align="center">此<code>KCallable</code>是否为抽象的</td>
</tr>
<tr>
<td align="center"><code>isFinal: Boolean</code></td>
<td align="center">此<code>KCallable</code>是否为<code>final</code></td>
</tr>
<tr>
<td align="center"><code>isOpen: Boolean</code></td>
<td align="center">此<code>KCallable</code>是否为<code>open</code></td>
</tr>
<tr>
<td align="center"><code>name: String</code></td>
<td align="center">此<code>KCallable</code>的名称</td>
</tr>
<tr>
<td align="center"><code>parameters: List&lt;KParameter&gt;</code></td>
<td align="center">调用此<code>KCallable</code>所需的参数</td>
</tr>
<tr>
<td align="center"><code>returnType: KType</code></td>
<td align="center">此<code>KCallable</code>的返回类型</td>
</tr>
<tr>
<td align="center"><code>typeParameters: List&lt;KTypeParameter&gt;</code></td>
<td align="center">此<code>KCallable</code>的类型参数</td>
</tr>
<tr>
<td align="center"><code>visibility: KVisibility?</code></td>
<td align="center">此<code>KCallable</code>的可见性</td>
</tr>
<tr>
<td align="center"><code>call(vararg args: Any?): R</code></td>
<td align="center">给定函数调用此<code>KCallable</code></td>
</tr>
</tbody></table>
<p>在java中，我们可以通过<code>Field.set(...)</code>来更改某个属性的值。在Kotlin中，可以很轻松的通过<code>call</code>实现。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Stu</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>, <span class="keyword">var</span> address: String)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">changeAddress</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> p = Stu(<span class="string">&quot;John&quot;</span>, <span class="number">25</span>, <span class="string">&quot;New York&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> props = p::<span class="keyword">class</span>.memberProperties</span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="keyword">when</span> (prop) &#123;</span><br><span class="line">            <span class="keyword">is</span> KMutableProperty&lt;*&gt; -&gt; prop.setter.call(p, <span class="string">&quot;London&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span> -&gt; prop.call(p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>KMutableProperty</code>的API仅仅只比<code>KProperty</code>多了一个<code>setter</code>函数。</p>
<p>其他反射及其API自行查阅官网文档。</p>
<h2 id="Kotlin的注解"><a href="#Kotlin的注解" class="headerlink" title="Kotlin的注解"></a>Kotlin的注解</h2><p>在 Kotlin 中，注解（Annotations）具有以下作用：</p>
<ol>
<li>提供元数据：注解可以用来提供关于程序元素的额外信息。通过在代码中添加注解，你可以指定程序元素的某些特定细节或属性，这些信息可以被其他代码或工具所利用。</li>
<li>用于静态检查和编译时处理：Kotlin 中的注解可以被用于在编译时检查代码，并触发特定的行为或处理。这样可以帮助你在编译时对代码进行额外的检查或生成额外的代码。</li>
<li>框架集成和元编程：注解在许多框架中起到重要作用，比如依赖注入、RESTful 服务的开发、ORM、序列化和反序列化等。注解还被广泛用于编写元编程的代码，比如自动生成代码或进行代码分析等。</li>
<li>用于标记和文档化：注解可以用于标记特定的代码块、类或函数，并且在文档生成工具中用于生成文档。通过使用注解，你可以方便地为代码添加标记和文档信息。</li>
</ol>
<p>Kotlin还引入了精确的注解控制语法。</p>
<table>
<thead>
<tr>
<th align="center">用法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>@file:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于文件</td>
</tr>
<tr>
<td align="center"><code>@property:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于属性</td>
</tr>
<tr>
<td align="center"><code>@field:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于字段</td>
</tr>
<tr>
<td align="center"><code>@get:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于<code>Getter</code></td>
</tr>
<tr>
<td align="center"><code>@setter:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于<code>Setter</code></td>
</tr>
<tr>
<td align="center"><code>@receiver:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于扩展函数或属性</td>
</tr>
<tr>
<td align="center"><code>@param:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于构造函数参数</td>
</tr>
<tr>
<td align="center"><code>@setparam:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于<code>Setter</code>的参数</td>
</tr>
<tr>
<td align="center"><code>@delegate:annotation</code></td>
<td align="center"><code>annotation</code>注解作用于存储代理实例的字段</td>
</tr>
</tbody></table>
<p>在Kotlin中，通过在<code>class</code>前增加<code>annotation</code>关键字即可创建注解。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">Cache</span>(<span class="keyword">val</span> namespace: String, <span class="keyword">val</span> expires: <span class="built_in">Int</span>)</span><br><span class="line"><span class="keyword">annotation</span> <span class="keyword">class</span> <span class="title class_">CacheKey</span>(<span class="keyword">val</span> keyName: String,<span class="keyword">val</span> buckets: IntArray)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Cache(<span class="string">&quot;hero&quot;</span>, 3600)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Hero</span>(</span><br><span class="line">    <span class="meta">@property:CacheKey</span>(<span class="string">&quot;name&quot;</span>, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="meta">@field:CacheKey</span>(<span class="string">&quot;attack&quot;</span>, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line">    <span class="keyword">val</span> attack: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="meta">@get:CacheKey</span>(<span class="string">&quot;defense&quot;</span>, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line">    <span class="keyword">val</span> defense: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> initHp: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="协程的启动"><a href="#协程的启动" class="headerlink" title="协程的启动"></a>协程的启动</h3><p>协程需要运行在协程上下文环境，在非协程环境中凭空启动协程，有三种方式。</p>
<ol>
<li><p><code>runBlocking&#123;&#125;</code></p>
<p>启动一个新协程，并阻塞当前线程，直到其内部所有逻辑以及子协程逻辑全部执行完成。</p>
</li>
<li><p><code>GlobalScope.launch&#123;&#125;</code></p>
<p>在应用范围内启动一个新协程，协程的生命周期与应用程序一致。这样启动的协程并不能使线程保活，就像守护线程。</p>
<p>由于这样启动的协程存在启动协程的组件已被销毁但协程还存在的情况，极限情况下可能导致资源耗尽，因此并不推荐这样启动，尤其是在客户端这种需要频繁创建销毁组件的场景。</p>
</li>
<li><p>实现<code>CoroutineScope + launch&#123;&#125;</code></p>
<p>这是在应用中最推荐使用的协程使用方式——为自己的组件实现<code>CoroutineScope</code>接口，在需要的地方使用<code>launch&#123;&#125;</code>方法启动协程。使得协程和该组件生命周期绑定，组件销毁时，协程一并销毁。从而实现安全可靠地协程调用。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>Kotlin基础学习从入门到入土</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://shewngeung.github.io/kotlin/Kotlin-Tutorial/">https://shewngeung.github.io/kotlin/Kotlin-Tutorial/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ShewnGeung</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-04-19</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-02-18</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kotlin/">Kotlin</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>喂猫猫吃饭~</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/git/Git%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="Git的安装与使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Git的安装与使用</div></div></a></div><div class="next-post pull-right"><a href="/maven/Apache%20Maven/" title="Apache Maven快速上手"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Apache Maven快速上手</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/algorithm/backtrack/" title="回溯算法学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-19</div><div class="title">回溯算法学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">ShewnGeung</div><div class="author-info__description">Programmer</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ShewnGeung"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">灰色的烟雾模糊了遥远的星座，眼前的一切失去了历史和名字，世界上只剩一些影影绰绰的温柔。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kotlin%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Kotlin基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">1.1.1.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.2.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if-else%E5%92%8Cwhen"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">if-else和when</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E5%92%8Cwhile"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">for和while</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">普通函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">函数类型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">中缀函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Kotlin%E6%A0%B8%E5%BF%83"><span class="toc-number">2.</span> <span class="toc-text">Kotlin核心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">类和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">类的扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">运算符重载函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%80%BC%E5%92%8C%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.3.</span> <span class="toc-text">空值和空类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84"><span class="toc-number">2.1.4.</span> <span class="toc-text">解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.1.5.</span> <span class="toc-text">访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.</span> <span class="toc-text">类的封装和继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">2.2.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">2.2.3.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB"><span class="toc-number">2.2.4.</span> <span class="toc-text">数据类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.2.5.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.2.6.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.7.</span> <span class="toc-text">伴生对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object%E5%8D%95%E4%BE%8B"><span class="toc-number">2.2.8.</span> <span class="toc-text">object单例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.</span> <span class="toc-text">类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">可空类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Either%E4%BB%A3%E6%9B%BF%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.2.</span> <span class="toc-text">通过Either代替可空类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">2.4.</span> <span class="toc-text">类型检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.5.</span> <span class="toc-text">智能类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Any%E5%92%8CAny-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">Any和Any?类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Any%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">Any类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Any-%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.2.</span> <span class="toc-text">Any?类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">2.7.</span> <span class="toc-text">自动装箱与拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%93%E5%8D%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">数组的打印</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.2.</span> <span class="toc-text">多维数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.9.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%B8%8A%E7%95%8C"><span class="toc-number">2.9.1.</span> <span class="toc-text">类型上界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">2.9.2.</span> <span class="toc-text">类型擦除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98"><span class="toc-number">2.10.</span> <span class="toc-text">协变和逆变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.11.</span> <span class="toc-text">Lambda和集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%8E%A5%E6%94%B6%E8%80%85%E7%9A%84Lambda"><span class="toc-number">2.11.1.</span> <span class="toc-text">带接收者的Lambda</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with%E5%92%8Capply"><span class="toc-number">2.11.2.</span> <span class="toc-text">with和apply</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.12.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E5%92%8C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">2.12.1.</span> <span class="toc-text">可变集合和有序集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.12.2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%9B%86%E5%90%88"><span class="toc-number">2.12.3.</span> <span class="toc-text">惰性集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E5%92%8C%E6%9C%AB%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">2.12.3.1.</span> <span class="toc-text">中间操作和末端操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E5%BA%8F%E5%88%97"><span class="toc-number">2.12.3.2.</span> <span class="toc-text">无限序列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%92%8C%E6%89%A9%E5%B1%95"><span class="toc-number">2.13.</span> <span class="toc-text">多态和扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">2.13.1.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%A4%9A%E6%80%81"><span class="toc-number">2.13.1.1.</span> <span class="toc-text">参数多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E8%AE%BE%E5%A4%9A%E6%80%81"><span class="toc-number">2.13.1.2.</span> <span class="toc-text">特设多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">2.13.2.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0"><span class="toc-number">2.13.2.1.</span> <span class="toc-text">扩展函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">2.13.2.2.</span> <span class="toc-text">实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.13.2.3.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7"><span class="toc-number">2.13.2.4.</span> <span class="toc-text">扩展属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">2.14.</span> <span class="toc-text">元编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kotlin%E4%B8%AD%E7%9A%84%E5%8F%8D%E5%B0%84"><span class="toc-number">2.14.1.</span> <span class="toc-text">Kotlin中的反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KClass"><span class="toc-number">2.14.2.</span> <span class="toc-text">KClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KCallable"><span class="toc-number">2.14.3.</span> <span class="toc-text">KCallable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kotlin%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.15.</span> <span class="toc-text">Kotlin的注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">2.16.</span> <span class="toc-text">协程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-number">2.16.1.</span> <span class="toc-text">协程的启动</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E6%88%91%E5%9C%A8Java%E5%AD%A6%E6%96%A9%E7%A5%9E/%E6%88%91%E5%9C%A8Java%E5%AD%A6%E6%96%A9%E7%A5%9E%E4%B9%8BJUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="我在Java学斩神：JUC并发编程">我在Java学斩神：JUC并发编程</a><time datetime="2025-04-23T07:14:17.000Z" title="发表于 2025-04-23 15:14:17">2025-04-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E6%88%91%E5%9C%A8Java%E5%AD%A6%E6%96%A9%E7%A5%9E/%E6%88%91%E5%9C%A8Java%E5%AD%A6%E6%96%A9%E7%A5%9E%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" title="我在Java学斩神：排序算法">我在Java学斩神：排序算法</a><time datetime="2025-04-21T12:05:44.000Z" title="发表于 2025-04-21 20:05:44">2025-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E6%88%91%E5%9C%A8Java%E5%AD%A6%E6%96%A9%E7%A5%9E/%E6%88%91%E5%9C%A8Java%E5%AD%A6%E6%96%A9%E7%A5%9E%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="我在Java学斩神：设计模式">我在Java学斩神：设计模式</a><time datetime="2025-04-21T08:55:48.000Z" title="发表于 2025-04-21 16:55:48">2025-04-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Database/Oracle%E4%BB%8E%E5%85%A5%E5%9C%9F%E5%88%B0%E8%AF%88%E5%B0%B8/" title="Oracle从入土到诈尸">Oracle从入土到诈尸</a><time datetime="2025-03-23T00:52:44.000Z" title="发表于 2025-03-23 08:52:44">2025-03-23</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/java/Java%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%83%A7%E7%83%A4/" title="Java从入门到烧烤">Java从入门到烧烤</a><time datetime="2025-01-23T05:36:27.000Z" title="发表于 2025-01-23 13:36:27">2025-01-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright"><span><b>&copy;2023 - 2025</b></span><span><b>&nbsp;&nbsp;By ShewnGeung</b></span></div><div class="footer_custom_text">Silence or relief is absolute.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-black?style=flat&logo=Vercel" title="本站默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div><div id="workboard"></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer src="/js/runtime.js"></script><script async src="/js/title.js"></script><script src="/js/f12.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="S&amp;G" data-fontsize="15px" data-random="false" async="async"></script><script src="//code.tidio.co/trblydd5ddrrs2py0rvywaogkgb1naoo.js" async="async"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    let isShow = false
    const close = () => {
      window.tidioChatApi.hide()
      isShow = false
    }
    
    const open = () => {
      window.tidioChatApi.open()
      window.tidioChatApi.show()
      isShow = true
    }

    const onTidioChatApiReady = () => {
      window.tidioChatApi.hide()
      window.tidioChatApi.on("close", close)
    }
    if (window.tidioChatApi) {
      window.tidioChatApi.on("ready", onTidioChatApiReady)
    } else {
      document.addEventListener("tidioChat-ready", onTidioChatApiReady)
    }

    window.chatBtnFn = () => {
      if (!window.tidioChatApi) return
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        window.tidioChatApi && window.tidioChatApi.hide()
      },
      show: () => {
        window.tidioChatApi && window.tidioChatApi.show()
      }
    }
  }
})()</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script></div></body><script>((function() {var callbacks = [],timeLimit = 50,open = false;setInterval(loop, 1);return {addListener: function(fn) {callbacks.push(fn);},cancleListenr: function(fn) {callbacks = callbacks.filter(function(v) {return v !== fn;});}}
function loop() {var startTime = new Date();debugger;if (new Date() - startTime > timeLimit) {if (!open) {callbacks.forEach(function(fn) {fn.call(null);});}open = true;window.stop();alert('你真坏，请关闭控制台！');document.body.innerHTML = "";} else {open = false;}}})()).addListener(function() {window.location.reload();});</script><script>function toDevtools(){
  let num = 0; 
  let devtools = new Date();
  devtools.toString = function() {
    num++;
    if (num > 1) {
        alert('你真坏，请关闭控制台！')
        window.location.href = "about:blank"
        blast();
    }
  }
  console.log('', devtools);
}
toDevtools();</script></html>